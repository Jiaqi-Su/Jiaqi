<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于Typora以及Gitee的云笔记搭建</title>
    <url>/2021/02/05/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E4%BA%8ETypora%E4%BB%A5%E5%8F%8AGithub%E7%9A%84%E4%BA%91%E7%AC%94%E8%AE%B0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>额，上次我发了一个marktext的简介，就是这个</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncftgz8zwj30ja092dmn.jpg" alt="Screen Shot 2021-02-05 at 10.14.16 AM"></p>
<p>然后就有小伙伴来询问</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncfxjwt2tj30n007mdh9.jpg" alt="IMG_0F68F7F98C6E-1"></p>
<p>说实话，我确实用过Typora，但是放弃的原因是因为Typora不支持图床，虽然除了这一个缺点，typora基本是完美的，但本着实事求是的原则，去确定了一下。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnchb5go99j30oo05wgm5.jpg" alt="image-20210205102311943"></p>
<p>well，这让我想起了一句话，自古评论出人才。</p>
<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p>web: <a href="https://typora.io/">https://typora.io/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncg4soy5xj31500igwg6.jpg" alt="Screen Shot 2021-02-05 at 10.24.59 AM"></p>
<p>很简单的下载安装，不多赘述</p>
<h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><p>1:preference</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncg8ad7yhj30v00egdvh.jpg" alt="Screen Shot 2021-02-05 at 10.27.34 AM"></p>
<p>2:language</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncg8vttfij313k0rg7ag.jpg" alt="Screen Shot 2021-02-05 at 10.28.48 AM"></p>
<p>3:Chinese</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncg9lpmh5j30u00w44i6.jpg" alt="image-20210205102947769"></p>
<p>4:关闭typora然后重启</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncgb2brc4j30v00h2k3o.jpg" alt="image-20210205103111616"></p>
<p>5: typora教程结束</p>
<p>都成为中文了，不需要其余的过多阐释了</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gnch52x7pgj31wz0u0qfb.jpg" alt="image-20210205110001774"></p>
<p>6: gitee私人仓库搭建</p>
<p>选择gitee的原因是因为github在国外，怕会影响传输速度，新建一个仓库</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncgo9n0bmj30pc0fedhc.jpg" alt="Screen Shot 2021-02-05 at 10.43.24 AM"></p>
<p>7:随便写写</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncgpevklcj30u00xlte2.jpg" alt="Screen Shot 2021-02-05 at 10.44.48 AM"></p>
<p>8:建设本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test</span><br><span class="line">git init</span><br><span class="line">touch README.md</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git remote add origin https://gitee.com/luskyqi/test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>9:以后所有的日志都在本地test文件夹下进行编写</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncgrtksrwj3162090abq.jpg" alt="Screen Shot 2021-02-05 at 10.47.08 AM"></p>
<p>10:自动同步，python ，每10mins同步一次，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">job</span>(<span class="params"><span class="built_in">dir</span></span>):</span></span><br><span class="line">    curtime = time.ctime()</span><br><span class="line">    os.chdir(<span class="built_in">dir</span>)</span><br><span class="line">    os.system(<span class="string">&#x27;git add .&#x27;</span>)</span><br><span class="line">    com_line=<span class="string">&#x27;git commit -m \&#x27;%s\&#x27;&#x27;</span>%(curtime)</span><br><span class="line">    os.system(com_line)</span><br><span class="line">    os.system(<span class="string">&#x27;git push -u origin master&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    job(<span class="string">&#x27;/Users/MyNote&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">600</span>)</span><br></pre></td></tr></table></figure>

<p>comment为最近一次同步的日期</p>
<p>然后，脚本在后台挂起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup python run.py &amp; </span><br></pre></td></tr></table></figure>

<p>11:成品图</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gncgy2e3klj31420cs40z.jpg" alt="Screen Shot 2021-02-05 at 10.49.43 AM"></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li><p>typora是一款很优质的markdown写作工具，功能健全，支持图床</p>
</li>
<li><p>下载安装简单，颜值在线</p>
</li>
<li><p>typora与gitee联用很适合作为云笔记使用</p>
</li>
</ul>
<h2 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h2><ul>
<li>基于typora以及gitee的模式是否可以演变为多人协作写作工具，可惜暂时不支持插件</li>
</ul>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
  </entry>
  <entry>
    <title>图的两种表示方法以及与分子文件的关系</title>
    <url>/2021/02/12/%E7%A7%91%E7%A0%94%E5%B7%A5%E5%85%B7/%E5%9B%BE%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%B8%8E%E5%88%86%E5%AD%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<blockquote>
<p>参考：</p>
<ul>
<li><a href="https://liuyangjun.blog.csdn.net/">https://liuyangjun.blog.csdn.net/</a></li>
<li><a href="https://liuyangjun.blog.csdn.net/article/details/82759650">https://liuyangjun.blog.csdn.net/article/details/82759650</a></li>
<li><a href="https://www.cnblogs.com/kaituorensheng/p/5423131.html">https://www.cnblogs.com/kaituorensheng/p/5423131.html</a></li>
</ul>
</blockquote>
<h3 id="通常使用两种不同的方式来表示一张图："><a href="#通常使用两种不同的方式来表示一张图：" class="headerlink" title="通常使用两种不同的方式来表示一张图："></a>通常使用两种不同的方式来表示一张图：</h3><ol>
<li><p>邻接矩阵</p>
<p>如下图，一张图有4个节点，则对应的邻接表中就有4行4列。</p>
<p>将这个矩阵命名为a，则a<sub>ij</sub>的值代表着i节点与j节点之间是否存在着边，我们用布尔值0和1来表示两种状态，0表示两点之间无连接。1表示两点之间存在着边连接。</p>
<p>因为是无向图，则a<sub>ij</sub>与a<sub>ji</sub>表示的值是一样的.</p>
<p>无向图的邻接矩阵关于斜对角线对称。</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/SouthEast.png" alt="img" style="zoom:50%;" />

<ol start="2">
<li><p>邻接表</p>
<p>邻接矩阵将所有点与点之间的关系都表示出来，而邻接表则只是把存在关系的点表示了出来。</p>
<p>第0行只有1个1节点，即表示与0节点相连的节点只有1节点，第1行有0,2,3这3个节点，表示着和1节点相连的节点有3个，即0节点，2节点，3节点。第2行后面有1,3节点，表示与2节点相连的节点有两个，分别是1节点和3节点，以此类推……</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/SouthEast-20210212185421093.png" alt="img" style="zoom:50%;" />

<p>邻接表表示法也可以用来表示有向图，如下图</p>
</li>
</ol>
</li>
</ol>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/SouthEast-20210212190434746.png" alt="img" style="zoom:50%;" />



<p>邻接表相比于邻接矩阵来说，所占用的空间更小，这是邻接表的一个优势。但是邻接表如果表示的是一个有很多条边的图，即稠密图的话，则邻接表的优势就不能够完好的体现了。因此，对于一个图来说，我们要根据具体的情况来判断使用哪种方式去表示图，一般邻接表适合表示稀疏图，邻接矩阵适合表示稠密图。</p>
<h3 id="分子格式文件"><a href="#分子格式文件" class="headerlink" title="分子格式文件"></a>分子格式文件</h3><p>分子储存文件最主要的是储存其三维坐标以及这些点之间的联系，这里以mol2文件为例</p>
<p>首先看官网介绍：</p>
<p>MOL2格式：<a href="http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/**mol2**.pdf">http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/**mol2**.pdf</a></p>
<p>一个简单的mol2格式文件</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210212191419119.png" alt="image-20210212191419119" style="zoom:50%;" />



<p>我们看<code>@&lt;TRIPOS&gt;BOND</code>这一项，</p>
<p>其格式为：</p>
<p><code>bond_id origin_atom_id target_atom_id bond_type</code></p>
<ul>
<li>bond_id (integer) =键ID号</li>
<li>origin_atom_id (integer) = 键初始端原子ID</li>
<li>target_atom_id (integer) = 键末端原子ID</li>
<li>bond_type (string) = 键类型</li>
<li>status_bits (string) = 与键关联的SYBYL状态位。 <strong>这些不应该由用户设置</strong>。 有效状态值为TYPECOL，GROUP，CAP，BACKBONE，DICT和INTERRES。</li>
</ul>
<p><code>Bond Types</code></p>
<ul>
<li>1 = 单键</li>
<li>2 = 双键</li>
<li>3 = 三键</li>
<li>am = 酰胺键</li>
<li>ar = 芳香键</li>
<li>du = 虚键（虚设键）</li>
<li>un = 未知 </li>
<li>nc = 非连接</li>
</ul>
<p><code>Example:</code></p>
<p>**5 4 9 am BACKBONE|DICT|INTERRES **</p>
<p><strong>5 4 9 am</strong></p>
<p>第一个示例中的键的ID号为5，并连接原子4和9。它是酰胺键。 状态位指示该键是主链的一部分，连接两个残基，并且在创建分子时使用了词典。 </p>
<p>第二个示例是相同键的最简表示。</p>
<p>从上述可以看出，mol2中的<code>@&lt;TRIPOS&gt;BOND</code>表示法为邻接表，且为有向图。</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210212192618369.png" alt="image-20210212192618369" style="zoom:50%;" />

<h4 id="用python表示图"><a href="#用python表示图" class="headerlink" title="用python表示图"></a>用python表示图</h4><p>要来看一个包，networkx</p>
<blockquote>
<p>Web:<a href="https://networkx.org/">https://networkx.org/</a></p>
</blockquote>
<p>安装：</p>
<figure class="highlight shell"><figcaption><span>l</span></figcaption><table><tr><td class="code"><pre><span class="line">pip install networkx</span><br></pre></td></tr></table></figure>
<p>教程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="comment">#创建图</span></span><br><span class="line">G = nx.Graph()</span><br><span class="line"><span class="comment">#加一个节点</span></span><br><span class="line">G.add_node(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#从列表中增加节点</span></span><br><span class="line">G.add_nodes_from([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">In [<span class="number">4</span>]: G.nodes</span><br><span class="line">Out[<span class="number">4</span>]: NodeView((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment">#加一条边</span></span><br><span class="line">G.add_edge(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">e = (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">G.add_edge(*e)  <span class="comment"># unpack edge tuple*，这步不懂，希望有大佬可以解释一下</span></span><br><span class="line"><span class="comment">#从列表中加边</span></span><br><span class="line">G.add_edges_from([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment">#查看</span></span><br><span class="line">In [<span class="number">6</span>]: G.edges</span><br><span class="line">Out[<span class="number">6</span>]: EdgeView([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment">#为点，边，图增加属性</span></span><br><span class="line"><span class="comment">#为图增加属性</span></span><br><span class="line">G = nx.Graph(day=<span class="string">&quot;Friday&quot;</span>)</span><br><span class="line">G.graph</span><br><span class="line">&#123;<span class="string">&#x27;day&#x27;</span>: <span class="string">&#x27;Friday&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#修改属性</span></span><br><span class="line">G.graph[<span class="string">&#x27;day&#x27;</span>] = <span class="string">&quot;Monday&quot;</span></span><br><span class="line">G.graph</span><br><span class="line">&#123;<span class="string">&#x27;day&#x27;</span>: <span class="string">&#x27;Monday&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#为节点增加属性</span></span><br><span class="line">G.add_node(<span class="number">1</span>, time=<span class="string">&#x27;5pm&#x27;</span>)</span><br><span class="line">G.add_nodes_from([<span class="number">3</span>], time=<span class="string">&#x27;2pm&#x27;</span>)</span><br><span class="line">G.nodes[<span class="number">1</span>]</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line">&#123;<span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;5pm&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">G.nodes[<span class="number">1</span>][<span class="string">&#x27;room&#x27;</span>] = <span class="number">714</span></span><br><span class="line">G.nodes.data()</span><br><span class="line"><span class="comment">#out</span></span><br><span class="line">NodeDataView(&#123;<span class="number">1</span>: &#123;<span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;5pm&#x27;</span>, <span class="string">&#x27;room&#x27;</span>: <span class="number">714</span>&#125;, <span class="number">3</span>: &#123;<span class="string">&#x27;time&#x27;</span>: <span class="string">&#x27;2pm&#x27;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#为边增加属性</span></span><br><span class="line">G.add_edge(<span class="number">1</span>, <span class="number">2</span>, weight=<span class="number">4.7</span> )</span><br><span class="line">G.add_edges_from([(<span class="number">3</span>, <span class="number">4</span>), (<span class="number">4</span>, <span class="number">5</span>)], color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">G.add_edges_from([(<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>&#125;), (<span class="number">2</span>, <span class="number">3</span>, &#123;<span class="string">&#x27;weight&#x27;</span>: <span class="number">8</span>&#125;)])</span><br><span class="line">G[<span class="number">1</span>][<span class="number">2</span>][<span class="string">&#x27;weight&#x27;</span>] = <span class="number">4.7</span></span><br><span class="line">G.edges[<span class="number">3</span>, <span class="number">4</span>][<span class="string">&#x27;weight&#x27;</span>] = <span class="number">4.2</span></span><br><span class="line"><span class="comment">#out</span></span><br><span class="line">In [<span class="number">21</span>]: G.edges.data()</span><br><span class="line">Out[<span class="number">21</span>]: EdgeDataView([(<span class="number">1</span>, <span class="number">2</span>, &#123;<span class="string">&#x27;weight&#x27;</span>: <span class="number">4.7</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>&#125;), (<span class="number">3</span>, <span class="number">4</span>, &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">4.2</span>&#125;), (<span class="number">3</span>, <span class="number">2</span>, &#123;<span class="string">&#x27;weight&#x27;</span>: <span class="number">8</span>&#125;), (<span class="number">4</span>, <span class="number">5</span>, &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;)])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="所以一张分子图可以表示为"><a href="#所以一张分子图可以表示为" class="headerlink" title="所以一张分子图可以表示为"></a>所以一张分子图可以表示为</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="comment">#创有向图</span></span><br><span class="line"><span class="comment">#苯环：smiles c1ccccc1</span></span><br><span class="line"><span class="comment">#原子序号： 1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">#原子坐标</span></span><br><span class="line"><span class="meta">@&lt;TRIPOS&gt;ATOM</span></span><br><span class="line"><span class="number">1</span>	 C01	<span class="number">1.405</span>	-<span class="number">0.000</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="number">2</span>	 C02	<span class="number">0.702</span>	<span class="number">1.216</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="number">3</span>	 C03	-<span class="number">0.702</span>	<span class="number">1.216</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="number">4</span>	 C04	-<span class="number">1.404</span>	-<span class="number">0.000</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="number">5</span>	 C05	-<span class="number">0.702</span>	-<span class="number">1.216</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="number">6</span>	 C06	<span class="number">0.702</span>	-<span class="number">1.216</span>	<span class="number">0.000</span>	C<span class="number">.2</span>	<span class="number">1</span>	UNK1	<span class="number">0.000</span>	</span><br><span class="line"><span class="comment">#邻接表</span></span><br><span class="line"><span class="meta">@&lt;TRIPOS&gt;BOND</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="comment">#键,[(1, 2), (1, 6),(2,3),(3,4),(4,5),(5,6)]</span></span><br><span class="line">GM = nx.DiGraph()</span><br><span class="line"><span class="comment">#从列表中增加节点</span></span><br><span class="line">GM.add_edges_from([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">6</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line"><span class="comment">#为节点增加属性</span></span><br><span class="line">GM.nodes[<span class="number">1</span>][<span class="string">&#x27;coord&#x27;</span>] = [<span class="number">1.405</span>,-<span class="number">0.000</span>,<span class="number">0.000</span>]</span><br><span class="line">GM.nodes[<span class="number">2</span>][<span class="string">&#x27;coord&#x27;</span>] = [<span class="number">0.702</span>,<span class="number">1.216</span>,<span class="number">0.000</span>]</span><br><span class="line">GM.nodes[<span class="number">3</span>][<span class="string">&#x27;coord&#x27;</span>] = [-<span class="number">0.702</span>,<span class="number">1.216</span>,<span class="number">0.000</span>]</span><br><span class="line">GM.nodes[<span class="number">4</span>][<span class="string">&#x27;coord&#x27;</span>] = [-<span class="number">1.404</span>,-<span class="number">0.000</span>,<span class="number">0.000</span>]</span><br><span class="line">GM.nodes[<span class="number">5</span>][<span class="string">&#x27;coord&#x27;</span>] = [-<span class="number">0.702</span>,-<span class="number">1.216</span>,<span class="number">0.000</span>]</span><br><span class="line">GM.nodes[<span class="number">6</span>][<span class="string">&#x27;coord&#x27;</span>] = [<span class="number">0.702</span>,-<span class="number">1.216</span>,<span class="number">0.000</span>]</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">In [<span class="number">38</span>]: GM.nodes.data()</span><br><span class="line">Out[<span class="number">38</span>]: NodeDataView(&#123;<span class="number">1</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [<span class="number">1.405</span>, -<span class="number">0.0</span>, <span class="number">0.0</span>]&#125;, <span class="number">2</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [<span class="number">0.702</span>, <span class="number">1.216</span>, <span class="number">0.0</span>]&#125;, <span class="number">6</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [<span class="number">0.702</span>, -<span class="number">1.216</span>, <span class="number">0.0</span>]&#125;, <span class="number">3</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [-<span class="number">0.702</span>, <span class="number">1.216</span>, <span class="number">0.0</span>]&#125;, <span class="number">4</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [-<span class="number">1.404</span>, -<span class="number">0.0</span>, <span class="number">0.0</span>]&#125;, <span class="number">5</span>: &#123;<span class="string">&#x27;coord&#x27;</span>: [-<span class="number">0.702</span>, -<span class="number">1.216</span>, <span class="number">0.0</span>]&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>科研工具</category>
      </categories>
  </entry>
  <entry>
    <title>更好的科研辅助工具-scholarscope</title>
    <url>/2021/02/09/%E7%A7%91%E7%A0%94%E5%B7%A5%E5%85%B7/%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A7%91%E7%A0%94%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7-scholarscope/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnp1owuqj316u0u0won.jpg" alt="image-20210209222739584"></p>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p> 你需要做的只是安装浏览器插件，不用再考虑其他问题 。</p>
<p>它能自动加载<strong>PubMed 期刊的影响因子</strong>，帮助用户筛选有用的期刊</p>
<p>添加文献下载链接，<strong>在校外也能一键下载文献（基于Sci-Hub）</strong>     </p>
<p>Web: <a href="https://www.scholarscope.cn/index.html">https://www.scholarscope.cn/index.html</a></p>
<p>​      </p>
<h3 id="支持浏览器："><a href="#支持浏览器：" class="headerlink" title="支持浏览器："></a>支持浏览器：</h3><p>火狐,Edge,Chrome,360,QQ</p>
<h3 id="安装以及使用："><a href="#安装以及使用：" class="headerlink" title="安装以及使用："></a>安装以及使用：</h3><p>基于火狐浏览器</p>
<ol>
<li><p>下载火狐浏览器</p>
<p>官网地址：<a href="https://www.firefox.com.cn/">https://www.firefox.com.cn/</a></p>
<p>你们如果再拐到其余地方的话，那我就不管了</p>
<p>安装即为程序化，不多赘述</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnphl8ewj31pc0u07co.jpg" alt="image-20210209223507765"></p>
</li>
<li><p>在地址框中输入：<a href="https://addons.mozilla.org/zh-CN/firefox/addon/scholarscope/">https://addons.mozilla.org/zh-CN/firefox/addon/scholarscope/</a></p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnrlu5dgj326m0pwahy.jpg" alt="image-20210209223709471"></p>
</li>
<li><p>点击添加</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnse5oxxj31hn0u07ky.jpg" alt="image-20210209223754210"></p>
</li>
<li><p>再次点击添加</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnsyp7tnj31xi0u0n9e.jpg" alt="image-20210209223827487"></p>
</li>
<li><p>出现下个界面，成功安装，会自动跳转到pubmed</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhntredu6j324s0u0ds6.jpg" alt="image-20210209223912887"></p>
</li>
<li><p>随便检索一些</p>
<p>新的页面上出现了分区以及排名，后面还可以自己diy</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnhnvihfogj311i0u0dou.jpg" alt="image-20210209224053369"></p>
</li>
<li><p>随便点进去一篇</p>
<p>右边的custom database就可以启动scihub进行下载，不过需要我们先配置一下</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnho26xxdpj31gi0u0wof.jpg" alt="image-20210209224720592"></p>
</li>
<li><p>点击插件图标</p>
<p>在浏览器右上方</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnho3mgp62j31gd0u0toh.jpg" alt="image-20210209224842445"></p>
</li>
<li><p>可以自己勾选被引指数，领域排名等等<br>  <img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnho46vafdj30j20zmq8p.jpg" alt="image-20210209224915348"></p>
</li>
<li><p>点击全局设置</p>
<p>然后在自定义数据库中，输入scihub的地址，点击确定</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnho6tyqg2j31lb0u07h3.jpg" alt="image-20210209225146966"></p>
</li>
<li><p>然后就可以使用custom databse进行下载了（本质是使用scihub进行下载）</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnho8xbv52j31350u0gwz.jpg" alt="image-20210209225348285"></p>
</li>
</ol>
<hr>
<h3 id="至此结束，祝大家新年快乐"><a href="#至此结束，祝大家新年快乐" class="headerlink" title="至此结束，祝大家新年快乐"></a>至此结束，祝大家新年快乐</h3>]]></content>
      <categories>
        <category>科研工具</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.1.学习所需资源</title>
    <url>/2021/02/21/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.1/</url>
    <content><![CDATA[<blockquote>
<p>Hi, 大家好。</p>
<p>开这个专栏是因为大家想学，而且，基本不需要更新的问题。</p>
<p>我们会从基础开始进行教学，继而进行安装，包使用，编程等等。</p>
<p>由于是总结以及教学方面，我会参考各种教程，如有引用，必定开源(本教程遵循MIT协议)。</p>
<p>当然，我们的实例重点是偏向于python使用与结构生物学，CADD，化学信息学等方面的使用。</p>
<p>（毕竟爬PubChem，也算爬虫的一种）</p>
<p>最终会提供几个实例，作为结尾，说到这里，又应该开一个仓库了。</p>
<p>(Typora + Gitee)[<a href="https://zhuanlan.zhihu.com/p/349427506]%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F%F0%9F%98%8E">https://zhuanlan.zhihu.com/p/349427506]自动上传了解一下？😎</a></p>
</blockquote>
<h3 id="官网：https-www-python-org"><a href="#官网：https-www-python-org" class="headerlink" title="官网：https://www.python.org/"></a>官网：<a href="https://www.python.org/">https://www.python.org/</a></h3><h3 id="版本："><a href="#版本：" class="headerlink" title="版本："></a>版本：</h3><p> Python 2.x 和 Python 3.x</p>
<p>本次教程使用<strong>Python 3.x</strong></p>
<h3 id="教程："><a href="#教程：" class="headerlink" title="教程："></a>教程：</h3><ol>
<li>廖雪峰：<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">https://www.liaoxuefeng.com/wiki/1016959663602400</a></li>
<li>中文翻译：<a href="https://docs.python.org/zh-cn/3/tutorial/index.html">https://docs.python.org/zh-cn/3/tutorial/index.html</a></li>
<li>菜鸟教程：<a href="https://www.runoob.com/">https://www.runoob.com/</a></li>
</ol>
<h3 id="Github"><a href="#Github" class="headerlink" title="Github:"></a>Github:</h3><ol>
<li>Python算法实现：<a href="https://github.com/TheAlgorithms/Python">https://github.com/TheAlgorithms/Python</a></li>
<li>100天从新手到大纲：<a href="https://github.com/jackfrued/Python-100-Days">https://github.com/jackfrued/Python-100-Days</a></li>
<li>Python Data Science 手书：<a href="https://github.com/jakevdp/PythonDataScienceHandbook">https://github.com/jakevdp/PythonDataScienceHandbook</a></li>
<li>机器学习100天：<a href="https://github.com/MLEveryday/100-Days-Of-ML-Code">https://github.com/MLEveryday/100-Days-Of-ML-Code</a></li>
<li>一些很漂亮的python应用：<a href="https://github.com/mahmoud/awesome-python-applications">https://github.com/mahmoud/awesome-python-applications</a></li>
<li>中文python笔记：<a href="https://github.com/lijin-THU/notes-python">https://github.com/lijin-THU/notes-python</a></li>
<li>pyhton初学者：<a href="https://github.com/Yixiaohan/codeparkshare">https://github.com/Yixiaohan/codeparkshare</a></li>
<li>慕课网的实战课程“C++算法与数据结构精讲“的全python实现：<a href="https://github.com/ShiveryMoon/Imooc-Algorithm-PythonEdition">https://github.com/ShiveryMoon/Imooc-Algorithm-PythonEdition</a></li>
</ol>
<h3 id="书籍："><a href="#书籍：" class="headerlink" title="书籍："></a>书籍：</h3><ol>
<li><p>Python编程 从入门到实践</p>
</li>
<li><p>“笨办法”学Python(第3版)</p>
</li>
<li><p>图灵程序设计丛书:Python基础教程(第2版)</p>
</li>
<li><p>BEST PYTHON BOOKS：<a href="https://pythonbooks.org/">https://pythonbooks.org</a></p>
</li>
</ol>
<h3 id="视频："><a href="#视频：" class="headerlink" title="视频："></a>视频：</h3><ol>
<li>mooc Python语言程序设计: <a href="https://www.icourse163.org/course/BIT-268001#/info">https://www.icourse163.org/course/BIT-268001#/info</a></li>
<li>mooc 高级语言程序设计(python) : <a href="https://www.icourse163.org/course/HIT-9003">https://www.icourse163.org/course/HIT-9003</a></li>
<li>YouTube Python零基础入门教程5小时完整版(2020年最新版):<a href="https://www.youtube.com/watch?v=yMOU8_hhLL8">https://www.youtube.com/watch?v=yMOU8_hhLL8</a></li>
<li>YouTube Python程序设计入门：<a href="https://www.youtube.com/watch?v=wqRlKVRUV_k&amp;list=PL-g0fdC5RMboYEyt6QS2iLb_1m7QcgfHk">https://www.youtube.com/watch?v=wqRlKVRUV_k&amp;list=PL-g0fdC5RMboYEyt6QS2iLb_1m7QcgfHk</a></li>
</ol>
<h3 id="IDE-集成开发环境"><a href="#IDE-集成开发环境" class="headerlink" title="IDE(集成开发环境):"></a>IDE(集成开发环境):</h3><ol>
<li>PyCharm:<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></li>
<li>Jupyter Notebook:<a href="https://jupyter.org/">https://jupyter.org</a></li>
<li>Ipython:<a href="https://ipython.org/">https://ipython.org/</a></li>
<li>Conda:<a href="https://conda.io/">https://conda.io</a></li>
<li>VS Code:<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
<li>Atom:<a href="https://atom.io/">https://atom.io/</a></li>
<li>Sublime Text:<a href="https://www.sublimetext.com/">https://www.sublimetext.com</a></li>
<li>Spyder:<a href="https://www.spyder-ide.org/">https://www.spyder-ide.org/</a></li>
</ol>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.10.迭代器</title>
    <url>/2021/03/01/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.10/</url>
    <content><![CDATA[<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器呢，是一种<strong>对象</strong>。。。。</p>
<blockquote>
<p>我如何和你们解释<strong>对象</strong>这个比较抽象的词呢（在某些同学仍然单身的情况下hhh）</p>
</blockquote>
<blockquote>
<p>言归正传，编程可以分为两类，面向过程的编程，以及面向对象的编程</p>
</blockquote>
<blockquote>
<p>我们写的一般普通的脚本是面向过程的，因为，处理问题比较简单，应用情景比较单一</p>
</blockquote>
<blockquote>
<p>但是如果对于比较复杂的操作一般会使用面向对象的编程</p>
</blockquote>
<blockquote>
<p>当然，你也可以记住一句话</p>
</blockquote>
<blockquote>
<p><strong>万物皆对象</strong></p>
</blockquote>
<p>为了更细致的了解,迭代器，我们先来给他下定义</p>
<ol>
<li>迭代器是可迭代的对象</li>
<li>迭代器只能往前不会后退。</li>
<li>迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong></li>
<li>字符串，列表，元组，字典对象都可用于创建迭代器</li>
<li>你也可以使用循环来进行遍历</li>
</ol>
<p>简而言之，一个字符串，列表或元组被迭代化后，他就变成了一个迭代器类似的存在，迭代器可以进行迭代，且只能向前不能向后</p>
<p>我们看个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a=<span class="string">&#x27;abcd&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="built_in">type</span>(b)</span><br><span class="line">Out[<span class="number">10</span>]: str_iterator</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">&#x27;a&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="string">&#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="string">&#x27;d&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-adb3e17b0219&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 next(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然列表，元祖也基本一致</span></span><br><span class="line">In [<span class="number">11</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: b = <span class="built_in">iter</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: print(b)</span><br><span class="line">&lt;list_iterator <span class="built_in">object</span> at <span class="number">0x7fc9b8337ed0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">18</span>-adb3e17b0219&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 next(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#当然，如果是字典的话</span></span><br><span class="line">In [<span class="number">19</span>]: a=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: <span class="built_in">iter</span>(a)</span><br><span class="line">Out[<span class="number">20</span>]: &lt;dict_keyiterator at <span class="number">0x7fc9b8331170</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: d = <span class="built_in">iter</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: <span class="built_in">next</span>(d)</span><br><span class="line">Out[<span class="number">22</span>]: <span class="string">&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: <span class="built_in">next</span>(d)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="string">&#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: <span class="built_in">next</span>(d)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">StopIteration                             Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">24</span>-9b2daf1403f5&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 next(d)</span><br><span class="line"></span><br><span class="line">StopIteration:</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用循环来进行遍历</span></span><br><span class="line">In [<span class="number">20</span>]: b = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>



<p>那其实现在，我们就有一个问题，为什么要用迭代器呢？</p>
<p>话说直接使用<code>for</code>，<code>while</code>循环遍历他不香吗？</p>
<p>一方面，同学们要了解，迭代的思想和精髓呀，这个你们高中老师就教过了，我就不教了，我们下一谈来直接写一个看看。</p>
<p>第二方面，迭代器所占的内存更小，我们看个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">33</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]:  print(sys.getsizeof(a))</span><br><span class="line"><span class="number">112</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = <span class="built_in">iter</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: print(sys.getsizeof(b))</span><br><span class="line"><span class="number">64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里我们使用两种方式创建了a，这个列表，一种是正常方式</span></span><br><span class="line"><span class="comment">#一种是正常方式，在正常方式下，a所占的内存为112字节</span></span><br><span class="line"><span class="comment">#一种是迭代器方式，a所占的内存的为64字节</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所以，<strong>迭代器比较香是因为它占据的内存比较小</strong></p>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.11.函数</title>
    <url>/2021/03/03/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.11.%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>手写一个迭代器，不要傻了，在你连函数都不会定义的情况下，我教你手写一个迭代器那是作死。</p>
<p>迭代器在后方</p>
<p>我们现在来看看<strong>函数,function</strong>定义</p>
<p>啥子叫个函数嘞</p>
<p>先来看看我对他的简化版定义</p>
<p><strong>当你写的代码太过复杂，不易被管理时，我们对代码所用的一种优化，一种代码的简洁结构</strong></p>
<p>当然他有一定的规则，来看看函数定义的规则(大部分摘自：<a href="https://www.runoob.com/python3/python3-function.html)%EF%BC%9A">https://www.runoob.com/python3/python3-function.html)：</a></p>
<ul>
<li>函数代码块以 <strong>def</strong> 关键词开头，后接函数标识符名称(就是下面的那个max)和圆括号 <code>()</code>，后面再加个冒号<code>:</code>。</li>
<li>任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</li>
<li>函数内容有缩进。</li>
<li>使用<code>return</code> 结束函数，函数会返回一个值，结束时不带return的话相当于返回 None。</li>
</ul>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/py-tup-10-26-1.png" alt="img"></p>
<h4 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数</span>):</span></span><br><span class="line"></span><br><span class="line">	函数</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span></span><br></pre></td></tr></table></figure>



<h3 id="一个实例"><a href="#一个实例" class="headerlink" title="一个实例"></a>一个实例</h3><p>仍然是<code>hellow world!</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: <span class="function"><span class="keyword">def</span> <span class="title">hw</span>(<span class="params">words</span>):</span></span><br><span class="line">    ...: 		 print(words)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: hw(<span class="string">&#x27;Hellow World!&#x27;</span>)</span><br><span class="line">Hellow World!</span><br></pre></td></tr></table></figure>

<p>然后让我们看看有<code>return</code>的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="function"><span class="keyword">def</span> <span class="title">plus</span>(<span class="params">a,b</span>):</span></span><br><span class="line">    ...:     c = a + b</span><br><span class="line">    ...:     <span class="keyword">return</span> c</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: plus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: d = plus(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: d</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>当然<code>return</code>在一个函数中也可以多次使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">72</span>]: <span class="function"><span class="keyword">def</span> <span class="title">pick_max</span>(<span class="params">a,b</span>):</span> </span><br><span class="line">    ...:     <span class="keyword">if</span> a &gt; b : </span><br><span class="line">    ...:         <span class="keyword">return</span> a </span><br><span class="line">    ...:     <span class="keyword">else</span>: </span><br><span class="line">    ...:         <span class="keyword">return</span> b </span><br><span class="line">    ...:                                                                                                                                                   </span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: pick_max(<span class="number">1</span>,<span class="number">2</span>)                                                                                                                                     </span><br><span class="line">Out[<span class="number">73</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: c = pick_max(<span class="number">1</span>,<span class="number">2</span>)                                                                                                                                 </span><br><span class="line"></span><br><span class="line">In [<span class="number">75</span>]: c                                                                                                                                                 </span><br><span class="line">Out[<span class="number">75</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure>



<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>我们来看下传参</p>
<ol>
<li><p>必须参数</p>
<p>你函数定义了一个参数，此函数必须要有相对应地参数否则运行便会报错</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="function"><span class="keyword">def</span> <span class="title">hw</span>(<span class="params">words</span>):</span></span><br><span class="line">    ...:     print(words)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: hw()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">21</span>-9982e5434f2d&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 hw()</span><br><span class="line"></span><br><span class="line">TypeError: hw() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;words&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认参数</p>
<p>我们有时会给参数加一些默认值，如果运行函数时传入修改的参数的话，那么函数一般运行便会使用默认值</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">23</span>]: <span class="function"><span class="keyword">def</span> <span class="title">hw</span>(<span class="params">a,b,c = <span class="number">5</span></span>):</span></span><br><span class="line">    ...:     print(a)</span><br><span class="line">    ...:     print(b)</span><br><span class="line">    ...:     print(c)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: hw(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: hw(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>可变参数</p>
<p>顾名思义，可变参数就是参数的个数是可变的，可以是1个也可以是n个</p>
<p>一般使用<code>*参数名</code>来进行表示,有时候你会常常看到这种形式<code>*args</code></p>
<p><code>*</code>参数用于解包tuple对象的每个元素，作为一个一个的位置参数传入到函数中</p>
<p>来举个例子，我想要计算（1，2，3，4）之间的加和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">26</span>]: <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*numbers</span>):</span></span><br><span class="line">    ...:     <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    ...:     <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">    ...:         <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    ...:     <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">Out[<span class="number">27</span>]: <span class="number">55</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*args</span>):</span></span><br><span class="line">    ...:     <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    ...:     <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">    ...:         <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    ...:     <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]:   calc(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">Out[<span class="number">31</span>]: <span class="number">30</span></span><br></pre></td></tr></table></figure>



<p>如果我们有一个列表或者元祖，如和进行传参呢</p>
<p>例如： a = [1,2,3,4]</p>
<p>这样？<code>calc(a[0],a[1],a[2],a[3])</code></p>
<p>虽然可行，但是太过赘述，python中容许在列表或者元祖前加<code>*</code>，将其作为可变参数传入</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">32</span>]: <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*args</span>):</span></span><br><span class="line">    ...:     <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    ...:     <span class="keyword">for</span> n <span class="keyword">in</span> args:</span><br><span class="line">    ...:         <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    ...:     <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: calc(*a)</span><br><span class="line">Out[<span class="number">34</span>]: <span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>还有另外一种形式<code>**karg</code>,使用这种形式参数在函数内部组装为一个dict。</p>
<p>我们来看个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: <span class="function"><span class="keyword">def</span> <span class="title">see</span>(<span class="params">**kw</span>):</span></span><br><span class="line">    ...:     print(kw)</span><br><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: see(a = <span class="number">1</span>,b = <span class="number">2</span>,c = <span class="number">3</span>,d = <span class="number">4</span>)</span><br><span class="line">&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>命名关键字参数</p>
<p>对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。</p>
<p>但是，我们需要检查某些关键字，以便查看使用者输入的参数是否是正确的。</p>
<p>。。。</p>
<p>把自己当作那些一无所知的用户吧，为他们设身处地的想想。</p>
<p>我们需要检查，用户的参数输入是否符合我们的标准</p>
<p>形式为<code>*,关键字,关键字</code></p>
<p>例如：我们需要检查用户是否输入了<code>id</code>,<code>smi</code>这两个参数，化学信息学初步引入hhh</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">45</span>]: <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">*,<span class="built_in">id</span>,smi</span>):</span></span><br><span class="line">    ...:     print(<span class="built_in">id</span>,smi)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: get(<span class="built_in">id</span>=<span class="number">1</span>,smi=<span class="string">&#x27;c1ccccc1&#x27;</span>)</span><br><span class="line"><span class="number">1</span> c1ccccc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果缺少id</span></span><br><span class="line">In [<span class="number">47</span>]: get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">47</span>-f3ae4c96f67d&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 get(id=1)</span><br><span class="line"></span><br><span class="line">TypeError: get() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;smi&#x27;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 如果缺少smi</span></span><br><span class="line">In [<span class="number">48</span>]: get(smi = <span class="string">&#x27;c1ccccc1&#x27;</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">48</span>-988e95298c74&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 get(smi = &#x27;c1ccccc1&#x27;)</span><br><span class="line"></span><br><span class="line">TypeError: get() missing <span class="number">1</span> required keyword-only argument: <span class="string">&#x27;id&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>参数组合</p>
<p>额，我就假设你们对前面的内容理解了</p>
<p>阿弥陀佛</p>
<p>我们已知有上述几种参数的形式，那么在定义函数的时候，这些参数是否是有顺序的呢</p>
<p>答案是有的</p>
<p><strong>参数的顺序必须是：必须参数、默认参数、可变参数/命名关键字参数和关键字参数</strong></p>
<p>详细可以看：<a href="https://www.jianshu.com/p/98f7e34845b5">https://www.jianshu.com/p/98f7e34845b5</a></p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里简单引入驼峰命名法，其实就是justdo不好看hhh</span></span><br><span class="line"><span class="comment"># 驼峰命名法：https://baike.baidu.com/item/骆驼命名法</span></span><br><span class="line">In [<span class="number">49</span>]: <span class="function"><span class="keyword">def</span> <span class="title">just_do</span>(<span class="params">a, b, c=<span class="number">0</span>, *, d, **kw</span>):</span></span><br><span class="line">    ...:     print(<span class="string">&#x27;a =&#x27;</span>, a, <span class="string">&#x27;b =&#x27;</span>, b, <span class="string">&#x27;c =&#x27;</span>, c, <span class="string">&#x27;d =&#x27;</span>, d, <span class="string">&#x27;kw =&#x27;</span>, kw)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]:  just_do(<span class="number">1</span>, <span class="number">2</span>, d=<span class="number">99</span>, ext=<span class="literal">None</span>)</span><br><span class="line">a = <span class="number">1</span> b = <span class="number">2</span> c = <span class="number">0</span> d = <span class="number">99</span> kw = &#123;<span class="string">&#x27;ext&#x27;</span>: <span class="literal">None</span>&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.12.列表生成式.1</title>
    <url>/2021/03/03/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.12.%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="额"><a href="#额" class="headerlink" title="额"></a>额</h3><p>竟然就到了函数，为什么这么快，我。。。是不是落了一些hh</p>
<p>来看一个我经常使用的方式</p>
<p>**列表生成式 **</p>
<p>一般来说我们如果要创建一个列表的话，那么可选的方案有</p>
<ol>
<li><p>直接定义列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="built_in">list</span></span><br></pre></td></tr></table></figure></li>
<li><p>将其余数据结构直接列表化</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">type</span>(b)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="built_in">tuple</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: c = <span class="built_in">list</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: print(c)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>先创建一个空列表，然后往里面塞元素</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">8</span>]: d = []</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">   ...:     d.append(i)</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: d</span><br><span class="line">Out[<span class="number">10</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="built_in">type</span>(d)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="built_in">list</span></span><br></pre></td></tr></table></figure>



<p>但是python提供了一个更为强大的列表生成方案</p>
<p>他的一般形式是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表 &#x3D; [表达式 for i in 列表]</span><br></pre></td></tr></table></figure>

<p>当然你也可以复杂一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">列表 &#x3D; [表达式 for i in 列表 判断式]</span><br></pre></td></tr></table></figure>

<p>那么我们就可以这样使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: a</span><br><span class="line">Out[<span class="number">13</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: a = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: a</span><br><span class="line">Out[<span class="number">15</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>甚至于这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: a = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>) <span class="keyword">if</span> i &gt; <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: a</span><br><span class="line">Out[<span class="number">17</span>]: [<span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.13.列表生成式.2</title>
    <url>/2021/03/04/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.13.%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F/</url>
    <content><![CDATA[<p> 上篇我们说到了列表生成式</p>
<p>你可以很简单的通过</p>
<p><code>a = [i for i in b]</code></p>
<p>来搭建一个列表</p>
<p><strong>但是，问题还在于内存</strong>，是不是有种熟悉的味道</p>
<p>是的，你可以在生成列表之后使用迭代器来减少内存</p>
<p>其实方法很简单，<del>我是为了水文才拆成了两篇</del>,怕你们记不住</p>
<p>我们只需要将<code>[]</code>修改为<code>()</code>便可以直接生成一个迭代器</p>
<p>我们看个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: a = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">4</span>]: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: sys.getsizeof(a)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">9032</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: b = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: sys.getsizeof(b)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">128</span></span><br></pre></td></tr></table></figure>



<p>我们生成迭代器之后的使用方法和原来的一样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="built_in">next</span>(b)</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当然，你也可以通过循环来进行调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: b = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>好，水文结束，大家早午晚安</p>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.14.模块(包)的使用</title>
    <url>/2021/03/05/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.14.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>本来打算写类的，但是想了下，写一个类然后打包发布，对于使用者来说难度有点大</p>
<p>所以我们就简单介绍一下包的使用和安装，足够大家使用就好</p>
<p><strong>python的一大优势就是有很多的第三方包</strong></p>
<ul>
<li><p>蛋白设计：PyRosetta等</p>
</li>
<li><p>化学信息学：Rdkit，PyBel，ODDT等</p>
</li>
<li><p>生物信息学：BioPython，Dash Bio等</p>
</li>
<li><p>AI：Sklearn，Tensorflow，PyTorch等</p>
</li>
</ul>
<p>当你熟练的使用这些包的时候，就可以很方便的使用各个学科的相关知识，降低你的入门难度，</p>
<p>而一些，你只需要输入**<code>import everything</code>**就可以实现</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/OIP.eTnkGiSxg4Ri-FmUNTGIgwHaEh.jpeg" alt="OIP.eTnkGiSxg4Ri-FmUNTGIgwHaEh"></p>
<p>我们先来看下python自带的一些包</p>
<p>python内置了一些很有用的模块</p>
<p>几个例子，<code>os, sys,time</code>等</p>
<p>我们看下使用</p>
<p>以<a href="https://www.runoob.com/python/os-file-methods.html">os</a>为例</p>
<p>os是<code>operating system</code>的缩写，他是python与系统进行交互的接口</p>
<p>我们来看几个常见的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先import</span></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#获取当前路径</span></span><br><span class="line">In [<span class="number">2</span>]: os.getcwd()</span><br><span class="line">Out[<span class="number">2</span>]: <span class="string">&#x27;/Users/user&#x27;</span></span><br><span class="line"><span class="comment">#显示当前路径下的目录和文件列表</span></span><br><span class="line">In [<span class="number">3</span>]: os.listdir()</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">[<span class="string">&#x27;1S2d.pdb&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;knime&#x27;</span>]</span><br><span class="line"><span class="comment"># 更改工作目录</span></span><br><span class="line">In [<span class="number">5</span>]: os.chdir(<span class="string">&#x27;Public/&#x27;</span>)</span><br><span class="line"><span class="comment"># 如果你想看os的相关帮助的话</span></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">help</span>(os)</span><br><span class="line">Help on module os:</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    os - OS routines <span class="keyword">for</span> NT <span class="keyword">or</span> Posix depending on what system we<span class="string">&#x27;re on.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">MODULE REFERENCE</span></span><br><span class="line"><span class="string">    https://docs.python.org/3.8/library/os</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The following documentation is automatically generated from the Python</span></span><br><span class="line"><span class="string">    source files.  It may be incomplete, incorrect or include features that</span></span><br><span class="line"><span class="string">    are considered implementation detail and may vary between Python</span></span><br><span class="line"><span class="string">    implementations.  When in doubt, consult the module reference at the</span></span><br><span class="line"><span class="string">    location listed above.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DESCRIPTION</span></span><br><span class="line"><span class="string">    This exports:</span></span><br><span class="line"><span class="string">      - all functions from posix or nt, e.g. unlink, stat, etc.</span></span><br><span class="line"><span class="string">      - os.path is either posixpath or ntpath</span></span><br><span class="line"><span class="string">      - os.name is either &#x27;</span>posix<span class="string">&#x27; or &#x27;</span>nt<span class="string">&#x27;</span></span><br><span class="line"><span class="string">      - os.curdir is a string representing the current directory (always &#x27;</span>.<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">      - os.pardir is a string representing the parent directory (always &#x27;</span>..<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">      - os.sep is the (or a most common) pathname separator (&#x27;</span>/<span class="string">&#x27; or &#x27;</span>\\<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">      - os.extsep is the extension separator (always &#x27;</span>.<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">      - os.altsep is the alternate pathname separator (None or &#x27;</span>/<span class="string">&#x27;)</span></span><br><span class="line"><span class="string"># 或者只是想看下os这个模块中定义过的函数或者变量</span></span><br><span class="line"><span class="string">In [10]: dir(os)</span></span><br><span class="line"><span class="string">Out[10]:</span></span><br><span class="line"><span class="string">[&#x27;</span>CLD_CONTINUED<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>CLD_DUMPED<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>CLD_EXITED<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>CLD_TRAPPED<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>DirEntry<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_CANTCREAT<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_CONFIG<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_DATAER<span class="string">R&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_IOER<span class="string">R&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_NOHOST<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_NOINPUT<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_NOPERM<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_NOUSE<span class="string">R&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_OK<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_OSER<span class="string">R&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_OSFILE<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_PROTOCOL<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_SOFTWARE<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_TEMPFAIL<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_UNAVAILABLE<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>EX_USAGE<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>F_LOCK<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>F_OK<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>F_TEST<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>F_TLOCK<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>F_ULOCK<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>MutableMapping<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>NGROUPS_MAX<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>O_ACCMODE<span class="string">&#x27;,</span></span><br><span class="line"><span class="string"> &#x27;</span>O_APPEND<span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.15.模块(包)的安装</title>
    <url>/2021/03/06/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.15.%E6%A8%A1%E5%9D%97(%E5%8C%85)%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>上一谈中我们使用了Python自带的包进行使用来阐述</p>
<p>这一部分，我们来看看第三方python包，如何安装，如何使用</p>
<p>以BioPython为例，难度低，用途比较广</p>
<p>biopython网站：<a href="https://biopython.org/wiki/Documentation">https://biopython.org/wiki/Documentation</a></p>
<h3 id="biopython简介"><a href="#biopython简介" class="headerlink" title="biopython简介"></a>biopython简介</h3><p><a href="https://www.yiibai.com/biopython/biopython_introduction.html">Biopython是Python的最大，最受欢迎的生物信息学软件包。它包含许多用于常规生物信息学任务的不同子模块。它由Chapman和Chang开发，主要使用Python编写。它还包含C代码，以优化软件的复杂计算部分。它可以在Windows，Linux，Mac OS X等操作系统上运行。</a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol>
<li><p>pip</p>
<p>pip是python的包管理器</p>
<p><code>pip install biopython</code></p>
<p>你可以在这个网站上查询需要安装的python包：<a href="https://pypi.org/">https://pypi.org</a></p>
<p>如果你需要安装特定的biopython版本的话</p>
<p><code>pip install biopython==version</code></p>
</li>
<li><p>conda</p>
<p>conda是一个强大的开源的软件包管理系统和环境管理系统</p>
<p>你可以在这个网站上查询需要安装的python包</p>
<p><code>conda install biopython</code></p>
<p>如果需要安装特定的版本</p>
<p><code>conda install biopython=version</code></p>
</li>
<li><p>离线安装</p>
<p>以上两种都属于在线安装，也即为有网状态下</p>
<p>下面来看下离线状态下如何安装python的第三方包</p>
<p>首先，我们要找到软件的官网</p>
<p>然后下载其文件：<a href="http://biopython.org/DIST/biopython-1.78.zip">http://biopython.org/DIST/biopython-1.78.zip</a></p>
<p>下载完成后，解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">user:biopython-1.78/ $ ls                                         [14:17:30]</span><br><span class="line">Bio                DEPRECATED.rst     NEWS.rst           Tests</span><br><span class="line">BioSQL             Doc                PKG-INFO           biopython.egg-info</span><br><span class="line">CONTRIB.rst        LICENSE.rst        README.rst         setup.cfg</span><br><span class="line">CONTRIBUTING.rst   MANIFEST.in        Scripts            setup.py</span><br></pre></td></tr></table></figure>



<p>  然后，我们直接运行<code>python setup.py install </code></p>
<p>  就可以进行安装</p>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>详细使用的话需要查看其原文档以及手册</p>
<p><a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html#sec3">http://biopython.org/DIST/docs/tutorial/Tutorial.html#sec3</a></p>
<p>我们这里的使用以3D模块为例：<a href="http://biopython.org/DIST/docs/tutorial/Tutorial.html#sec178">http://biopython.org/DIST/docs/tutorial/Tutorial.html#sec178</a></p>
<p>我们需要下载这个文件<code>1fat.cif</code>：<a href="http://files.rcsb.org/download/1FAT.cif">http://files.rcsb.org/download/1FAT.cif</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先导入</span></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">import</span> Bio</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">In [<span class="number">5</span>]: print(Bio.__version__)</span><br><span class="line"><span class="number">1.78</span></span><br><span class="line">In [<span class="number">15</span>]: <span class="keyword">from</span> Bio.PDB.MMCIFParser <span class="keyword">import</span> MMCIFParser</span><br><span class="line">    ...: parser = MMCIFParser()</span><br><span class="line">In [<span class="number">16</span>]: structure = parser.get_structure(<span class="string">&quot;1fat&quot;</span>, <span class="string">&quot;1fat.cif&quot;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 我们使用biopython获取了1fat这个蛋白的结构信息</span></span><br><span class="line"><span class="comment"># 然后来进行一个简单的示例</span></span><br><span class="line">In [<span class="number">18</span>]: <span class="keyword">for</span> model <span class="keyword">in</span> structure:</span><br><span class="line">    ...:     <span class="keyword">for</span> chain <span class="keyword">in</span> model:</span><br><span class="line">    ...:         <span class="keyword">for</span> residue <span class="keyword">in</span> chain:</span><br><span class="line">    ...:             <span class="keyword">for</span> atom <span class="keyword">in</span> residue:</span><br><span class="line">    ...:                 print(atom)</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line">&lt;Atom O&gt;</span><br><span class="line">&lt;Atom CB&gt;</span><br><span class="line">&lt;Atom CG&gt;</span><br><span class="line">&lt;Atom CD1&gt;</span><br><span class="line">&lt;Atom CD2&gt;</span><br><span class="line">&lt;Atom N&gt;</span><br><span class="line">&lt;Atom CA&gt;</span><br><span class="line">&lt;Atom C&gt;</span><br><span class="line">&lt;Atom O&gt;</span><br><span class="line">&lt;Atom N&gt;</span><br><span class="line">&lt;Atom CA&gt;</span><br><span class="line">&lt;Atom C&gt;</span><br><span class="line">&lt;Atom O&gt;</span><br><span class="line">&lt;Atom CB&gt;</span><br><span class="line">&lt;Atom CG&gt;</span><br><span class="line">&lt;Atom CD1&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是biopython中对于结构的解析</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/smcra.png" alt="img"></p>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.16.错误</title>
    <url>/2021/03/07/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.16.%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>在使用Python时报错是不可避免的事情</p>
<p>我们来看错误的产生以及分类，以及如何对其进行调试</p>
<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>python有两种错误，十分容易辨别</p>
<ol>
<li><p>语法错误</p>
<p>语法错误是因为不规范的代码引发的，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: <span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">  File <span class="string">&quot;&lt;ipython-input-3-2b688bc740d7&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> print(<span class="string">&#x27;Hello world&#x27;</span>)</span><br><span class="line">               ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>引发错误的内容就是少加了一个<code>:</code>，关键词是这个<code>SyntaxError: invalid syntax</code></p>
</li>
<li><p>异常</p>
<p>异常是python另外一个容易遇见的错误，即使你的语法是正常的，在运行期间也有可能遇到错误</p>
<p>可能原因有变量未定义,int与str搞错等等</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: c = <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印出一个未定义的变量</span></span><br><span class="line">In [<span class="number">8</span>]: print(d)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">NameError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">8</span>-85549cb1de5f&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 print(d)</span><br><span class="line"></span><br><span class="line">NameError: name <span class="string">&#x27;d&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数和字符串相加</span></span><br><span class="line">In [<span class="number">9</span>]: a + c</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-<span class="built_in">input</span>-<span class="number">9</span>-e81e582b6fa9&gt; <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">----&gt; 1 a + c</span><br><span class="line"></span><br><span class="line">TypeError: unsupported operand <span class="built_in">type</span>(s) <span class="keyword">for</span> +: <span class="string">&#x27;int&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.2.IDE简介</title>
    <url>/2021/02/22/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.2/</url>
    <content><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>我总喜欢把已有的信息放在前面，而不是最后。一方面是因为前人的树，致敬一下；另一方面，我的教学，也是从他们当中进行学习，汇总，精炼，如果觉得我的教程比较慢的话，你也可以直接去学习。</p>
<h3 id="IDE简介："><a href="#IDE简介：" class="headerlink" title="IDE简介："></a>IDE简介：</h3><blockquote>
<p>集成开发环境（IDE，Integrated Development Environment ）是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。所有具备这一特性的软件或者软件套（组）都可以叫集成开发环境。如微软的Visual Studio系列，Borland的C++ Builder、Delphi系列等。该程序可以独立运行，也可以和其它程序并用。IDE多被用于开发HTML应用软件。例如，许多人在设计网站时使用IDE（如HomeSite、DreamWeaver等），因为很多项任务会自动生成。微软的Visual Basic是早期的典型的可视化开发环境，后来的包括Borland公司的Delphi等。</p>
</blockquote>
<p>摘自：<a href="https://www.zhihu.com/topic/20018211/intro">https://www.zhihu.com/topic/20018211/intro</a></p>
<blockquote>
<p>Python 中IDE各凭习惯，环境以及爱好来进行使用</p>
</blockquote>
<blockquote>
<p>个人建议新手入坑PyCharm，虽然他慢，但是大部分图形化操作界面，容易上手，对新手很友好，当你不知道怎么配置的时候，default一般是最佳选项。社区版免费下载。</p>
</blockquote>
<blockquote>
<p>然后说说我的配置，我是conda，ipython，jupyter notebook三者联用。我安装的conda为miniconda不是anaconda，因为miniconda更快一点，体积更小一点，然后分别创造python2.x以及python3.x两个环境，在其中安装好ipython以及jupyter notebook进行使用。</p>
</blockquote>
<p><strong>后续的所有程序均在IDE中运行，如果你喜欢简单那么ipython，如果你需要一些可视化比较强的那么jupyter notebook，如果你需要一套强大的工具包那么PyCharm，vscode或者conda</strong></p>
<h3 id="IDE安装："><a href="#IDE安装：" class="headerlink" title="IDE安装："></a>IDE安装：</h3><ol>
<li><p>Pycharm安装：<a href="https://zhuanlan.zhihu.com/p/51780281">https://zhuanlan.zhihu.com/p/51780281</a></p>
<p>很简单的过程，不多做赘述</p>
</li>
<li><p>Conda安装：</p>
<p>miniconda版本：<a href="https://www.jianshu.com/p/edaa744ea47d">https://www.jianshu.com/p/edaa744ea47d</a></p>
<p>anaconda版本：<a href="https://blog.csdn.net/tqlisno1/article/details/108908775">https://blog.csdn.net/tqlisno1/article/details/108908775</a></p>
</li>
</ol>
<h3 id="IDE使用："><a href="#IDE使用：" class="headerlink" title="IDE使用："></a>IDE使用：</h3><p>基本就是Miniconda使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看conda版本</span><br><span class="line">conda -V/--version</span><br><span class="line">conda env list</span><br><span class="line"><span class="meta">#</span><span class="bash">激活或推出环境</span></span><br><span class="line">conda activate env_name</span><br><span class="line">conda deactivate</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">新建虚拟环境：</span></span><br><span class="line">conda create --name py36 python=3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">删除环境：</span></span><br><span class="line">conda remove -n py36 --all</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制环境：</span></span><br><span class="line">conda create -n newpy36 --clone py36</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有包：</span></span><br><span class="line">conda list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装包</span></span><br><span class="line">conda install package_name</span><br><span class="line"><span class="meta">#</span><span class="bash">package_name为包的名称</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">指定安装包版本</span></span><br><span class="line">conda install python=3.5</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">安装ipython</span></span><br><span class="line">conda install -c anaconda ipython </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动ipython</span></span><br><span class="line">ipython</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="conda-包查询网址：https-anaconda-org-anaconda"><a href="#conda-包查询网址：https-anaconda-org-anaconda" class="headerlink" title="conda 包查询网址：https://anaconda.org/anaconda"></a>conda 包查询网址：<a href="https://anaconda.org/anaconda">https://anaconda.org/anaconda</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mymac:~/ $ conda activate py3                                                                                [<span class="number">20</span>:<span class="number">21</span>:<span class="number">30</span>]</span><br><span class="line">(py3) mymac:~/ $ ipython                                                                                     [<span class="number">20</span>:<span class="number">26</span>:<span class="number">57</span>]</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.7</span> (default, Mar <span class="number">26</span> <span class="number">2020</span>, <span class="number">10</span>:<span class="number">32</span>:<span class="number">53</span>)</span><br><span class="line">Type <span class="string">&#x27;copyright&#x27;</span>, <span class="string">&#x27;credits&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;license&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">IPython <span class="number">7.13</span><span class="number">.0</span> -- An enhanced Interactive Python. Type <span class="string">&#x27;?&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: print(<span class="string">&#x27;hellow world!&#x27;</span>)</span><br><span class="line">hellow world!</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.3 :hello world；注释；数据类型</title>
    <url>/2021/02/22/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.3/</url>
    <content><![CDATA[<h3 id="开始第一个编程"><a href="#开始第一个编程" class="headerlink" title="开始第一个编程"></a>开始第一个编程</h3><p>当然是  输出 Hellow World</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">&#x27;Hellow World!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>有两种选项</p>
<ol>
<li>使用ipython或者jupyter notebook等，在其中直接输入此命令然后运行</li>
<li>保存此命令为<code>hellow.py</code>文件，在命令行中输入<code>python hellow.py</code></li>
</ol>
<p><strong>Welcom to Python!</strong></p>
<p>现在你已经完成了你的第一个程序，成功的输出了<code>Hellow World!</code>在屏幕上</p>
<p>接下来，我们会进行进一步的学习</p>
<h3 id="Python中的注释"><a href="#Python中的注释" class="headerlink" title="Python中的注释"></a>Python中的注释</h3><p>python可以进行单行注释，用<code>#</code>开头</p>
<p>也可以进行多行注释，使用三个单引号<code>&#39;&#39;&#39;</code>或者三个双引号<code>&quot;&quot;&quot;</code>将内容涵盖在内</p>
<p>如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: <span class="comment"># 这是一个注释</span></span><br><span class="line">    ...: print(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    ...: <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个单引号</span></span><br><span class="line"><span class="string">    ...: &#x27;&#x27;&#x27;</span></span><br><span class="line">    ...: print(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    ...: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">    ...: 这是多行注释，用三个双引号</span></span><br><span class="line"><span class="string">    ...: &quot;&quot;&quot;</span></span><br><span class="line">    ...: print(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">      </span><br><span class="line">Hello, World!</span><br><span class="line">Hello, World!</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<p><strong>我们为什么需要注释，以及该如何注释</strong></p>
<p>注释是编程能力的重要一部分，良好的注释能力意味着你有了良好的团队合作能力</p>
<p>想象一下，当你面对自己三年前编写的万行无注释代码时，会是什么样的感觉</p>
<p>但是注释也应该有一个标准，以便交流，这里推荐谷歌风格规范，不仅仅是注释，更是对其余方面也进行了阐释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Google 开源项目风格指南 (中文版)</span><br><span class="line"></span><br><span class="line">在线文档托管在 ReadTheDocs : 在线阅读最新版本 [https:&#x2F;&#x2F;google-styleguide.readthedocs.io&#x2F;zh_CN&#x2F;latest&#x2F;]</span><br><span class="line">中文风格指南 GitHub 托管地址：zh-google-styleguide [https:&#x2F;&#x2F;github.com&#x2F;zh-google-styleguide&#x2F;zh-google-styleguide]</span><br><span class="line">离线文档下载地址：release [https:&#x2F;&#x2F;github.com&#x2F;zh-google-styleguide&#x2F;zh-google-styleguide&#x2F;releases]”</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于函数的几个方面应该在特定的小节中进行描述记录， 这几个方面如下文所述. 每节应该以一个标题行开始. 标题行以冒号结尾. 除标题行外, 节的其他内容应被缩进2个空格.</span><br><span class="line"></span><br><span class="line">Args:</span><br><span class="line">列出每个参数的名字, 并在名字后使用一个冒号和一个空格, 分隔对该参数的描述.如果描述太长超过了单行80字符,使用2或者4个空格的悬挂缩进(与文件其他部分保持一致). 描述应该包括所需的类型和含义. 如果一个函数接受*foo(可变长度参数列表)或者**bar (任意关键字参数), 应该详细列出*foo和**bar.</span><br><span class="line"></span><br><span class="line">Returns: (或者 Yields: 用于生成器)</span><br><span class="line">描述返回值的类型和语义. 如果函数返回None, 这一部分可以省略.</span><br><span class="line"></span><br><span class="line">Raises:</span><br><span class="line">列出与接口有关的所有异常.”</span><br><span class="line"></span><br><span class="line">def fetch_smalltable_rows(table_handle: smalltable.Table,</span><br><span class="line">                        keys: Sequence[Union[bytes, str]],</span><br><span class="line">                        require_all_keys: bool &#x3D; False,</span><br><span class="line">) -&gt; Mapping[bytes, Tuple[str]]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Fetches rows from a Smalltable.</span><br><span class="line"></span><br><span class="line">    Retrieves rows pertaining to the given keys from the Table instance</span><br><span class="line">    represented by table_handle.  String keys will be UTF-8 encoded.</span><br><span class="line"></span><br><span class="line">    Args:</span><br><span class="line">        table_handle: An open smalltable.Table instance.</span><br><span class="line">        keys: A sequence of strings representing the key of each table</span><br><span class="line">        row to fetch.  String keys will be UTF-8 encoded.</span><br><span class="line">        require_all_keys: Optional; If require_all_keys is True only</span><br><span class="line">        rows with values set for all keys will be returned.</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        A dict mapping keys to the corresponding table row data</span><br><span class="line">        fetched. Each row is represented as a tuple of strings. For</span><br><span class="line">        example:</span><br><span class="line"></span><br><span class="line">        &#123;b&#39;Serak&#39;: (&#39;Rigel VII&#39;, &#39;Preparer&#39;),</span><br><span class="line">        b&#39;Zim&#39;: (&#39;Irk&#39;, &#39;Invader&#39;),</span><br><span class="line">        b&#39;Lrrr&#39;: (&#39;Omicron Persei 8&#39;, &#39;Emperor&#39;)&#125;</span><br><span class="line"></span><br><span class="line">        Returned keys are always bytes.  If a key from the keys argument is</span><br><span class="line">        missing from the dictionary, then that row was not found in the</span><br><span class="line">        table (and require_all_keys must have been False).</span><br><span class="line"></span><br><span class="line">    Raises:</span><br><span class="line">        IOError: An error occurred accessing the smalltable.</span><br><span class="line">		&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h3 id="Python中的数据类型"><a href="#Python中的数据类型" class="headerlink" title="Python中的数据类型"></a>Python中的数据类型</h3><p>数据类型和基本的数据结构是根本，这意味着你使用怎样的方式来存储数据</p>
<p>在进行实际使用时，我们使用等号（=）来进行赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: a = <span class="number">100</span>          <span class="comment"># 整型变量</span></span><br><span class="line">   ...: b = <span class="number">1000.0</span>       <span class="comment"># 浮点型变量</span></span><br><span class="line">   ...: c = <span class="string">&quot;runoob&quot;</span>     <span class="comment"># 字符串</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="built_in">type</span>(b)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="built_in">str</span></span><br><span class="line"><span class="comment">#当然，我们也可以更改变量类型</span></span><br><span class="line">In [<span class="number">14</span>]: d = <span class="built_in">str</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: <span class="built_in">type</span>(d)</span><br><span class="line">Out[<span class="number">15</span>]: <span class="built_in">str</span></span><br></pre></td></tr></table></figure>



<p>数据类型和基本的数据结构是根本，这意味着你使用怎样的方式来存储数据</p>
<ul>
<li><p>数值类型</p>
<ul>
<li>整数型(Int)：没有小数，无大小，你的电脑内存有多大，整数就可以创造多大</li>
<li>浮点型(float)：存在小数点，可以使用普通写法<code>1.23,3.5,-9.1</code>等，也可以使用科学计数法<code>2.5e2,2.5**10</code></li>
<li>复数型( (complex))：我使用的比较少， 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点–摘自，菜鸟教程</li>
</ul>
</li>
<li><p>字符串：字符串是最常见的数字类型，<code>hellow world!</code>便是</p>
<ul>
<li><p>我们可以直接进行赋值：例如<code>a = &#39;u can u up&#39;</code> 或者 <code>a = &quot;no can no bb&quot;</code>,当然你也可以使用<code>a = &quot;i say &#39;somthing&#39;&quot;</code>，来进行表示，唯一需要注意的一点是中英文的切换。</p>
</li>
<li><p>转义字符，python中的转衣字符有<code>\n</code>表示换行，<code>\t</code>表示制表符，我们最常见的用法是</p>
<ul>
<li>```python<br>In [61]: print(‘Hellow\tWorld!\nNi\tHao.’)<br>Hellow    World!<br>Ni    Hao.<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ 在进行使用时，如果你不想转义，则可以在，前面加&#96;r&#96;,如下</span><br><span class="line"></span><br><span class="line">+ &#96;&#96;&#96;python</span><br><span class="line">  In [62]: print(r&#39;Hellow\tWorld!\nNi\tHao.&#39;)</span><br><span class="line">  Hellow\tWorld!\nNi\tHao.</span><br></pre></td></tr></table></figure></li>
<li>说到这个，不得不提起PDB格式(蛋白质数据专用格式)，PDB格式ATOM共80列，每一列都需要填充，也就是，你在分割时需要按照index进行分割，而不是<code>\t</code></li>
</ul>
</li>
</ul>
</li>
<li><p>布尔值：一个布尔值只有<code>True</code>、<code>False</code>两种值，布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算,常常用作比较，以及判断</p>
<ul>
<li><p>```python<br>In [68]: print(8 &gt; 7)</p>
<pre><code>...: print(8 &lt; 7)
</code></pre>
<p>True<br>False<br>In [75]: a<br>Out[75]: 7</p>
<p>In [76]: a &lt;10 and a &gt;5<br>Out[76]: True</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">+ 空值：&#96;None&#96;不能理解为&#96;0&#96;,&#96;&quot;&quot;&#96;,&#96;[]&#96;，&#96;False&#96;，&#96;None&#96;是一个特殊的空值。</span><br><span class="line"></span><br><span class="line">  + &#96;&#96;&#96;python</span><br><span class="line">    In [65]: a &#x3D; None</span><br><span class="line">        ...: type(a)</span><br><span class="line">    Out[65]: NoneType</span><br><span class="line">    In [66]: print(a)</span><br><span class="line">    None</span><br></pre></td></tr></table></figure></li>
<li><p>从类型层面上，<code>False</code>是布尔类型，而<code>None</code>是<code>class &#39;NoneType&#39;</code>；从意义层面上，<code>None</code>表示不存在，而<code>False</code>表示真假。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于数据类型与内存空间</p>
</blockquote>
<blockquote>
<p>在python中，如果改变变量的数值类型，那么其内存空间将会重新分配，但重新引用并不会造成内存空间的重分配</p>
<p>我们来看一个例子</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># a赋值为100</span></span><br><span class="line">In [<span class="number">26</span>]: a  = <span class="number">100</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment">#查看内存地址</span></span><br><span class="line">In [<span class="number">27</span>]: <span class="built_in">id</span>(a)</span><br><span class="line">Out[<span class="number">27</span>]: <span class="number">4452845280</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#查看数据类型</span></span><br><span class="line">In [<span class="number">28</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">28</span>]: <span class="built_in">int</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: <span class="built_in">id</span>(b)</span><br><span class="line">Out[<span class="number">30</span>]: <span class="number">4452845280</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: c = <span class="built_in">float</span>(a)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: <span class="built_in">type</span>(c)</span><br><span class="line">Out[<span class="number">32</span>]: <span class="built_in">float</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: <span class="built_in">id</span>(c)</span><br><span class="line">Out[<span class="number">33</span>]: <span class="number">4485900944</span></span><br><span class="line">  </span><br><span class="line">In [<span class="number">52</span>]: d = <span class="built_in">str</span>(a)</span><br><span class="line">  </span><br><span class="line">In [<span class="number">54</span>]: <span class="built_in">type</span>(d)</span><br><span class="line">Out[<span class="number">54</span>]: <span class="built_in">str</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: <span class="built_in">id</span>(d)</span><br><span class="line">Out[<span class="number">53</span>]: <span class="number">4485942256</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.5</title>
    <url>/2021/02/24/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.5/</url>
    <content><![CDATA[<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul>
<li><p>字典是经常使用的数据结构</p>
</li>
<li><p>字典分为key 以及value两部分</p>
</li>
<li><p>每个Key都可以对应一个value</p>
</li>
<li><p>使用<code>&#123;&#125;</code>来创建字典</p>
</li>
<li><p>字典的元素可以是比较任意的类型，例如列表，元祖等</p>
</li>
<li><p>字典的一般操作有创建，更新元素，删除元素，添加元素，以及遍历</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建一个空字典</span></span><br><span class="line">In [<span class="number">1</span>]: a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">2</span>]: <span class="built_in">dict</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 当然也可以创建一个非空字典</span></span><br><span class="line">In [<span class="number">4</span>]: b = &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: b</span><br><span class="line">Out[<span class="number">5</span>]: &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Zara&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在b中更新元素</span></span><br><span class="line">In [<span class="number">6</span>]: b[<span class="string">&#x27;Name&#x27;</span>]</span><br><span class="line">Out[<span class="number">6</span>]: <span class="string">&#x27;Zara&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: b[<span class="string">&#x27;Name&#x27;</span>] = <span class="string">&#x27;Xiaoming&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: b</span><br><span class="line">Out[<span class="number">8</span>]: &#123;<span class="string">&#x27;Name&#x27;</span>: <span class="string">&#x27;Xiaoming&#x27;</span>, <span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在删除b中元素</span></span><br><span class="line">In [<span class="number">9</span>]: <span class="keyword">del</span> b[<span class="string">&#x27;Name&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: b</span><br><span class="line">Out[<span class="number">10</span>]: &#123;<span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在b中添加元素</span></span><br><span class="line">In [<span class="number">11</span>]: b[<span class="string">&#x27;new&#x27;</span>] = <span class="string">&#x27;nihao&#x27;</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: b</span><br><span class="line">Out[<span class="number">12</span>]: &#123;<span class="string">&#x27;Age&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;Class&#x27;</span>: <span class="string">&#x27;First&#x27;</span>, <span class="string">&#x27;new&#x27;</span>: <span class="string">&#x27;nihao&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>集合是无序的，<strong>不重复的</strong></li>
<li>使用<code>set()</code>来创建一个集合</li>
<li>你可以添加元素，也可以删除元素</li>
<li>集合比较重要的是其运算求交集，并集等等</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个集合</span></span><br><span class="line">In [<span class="number">13</span>]: a = <span class="built_in">set</span>(<span class="string">&#x27;abracadabra&#x27;</span>)</span><br><span class="line">    ...: b = <span class="built_in">set</span>(<span class="string">&#x27;alacazam&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">In [<span class="number">24</span>]: a = <span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>])</span><br><span class="line">In [<span class="number">26</span>]: b = <span class="built_in">set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">In [<span class="number">25</span>]: a</span><br><span class="line">Out[<span class="number">25</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: b</span><br><span class="line">Out[<span class="number">27</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a</span><br><span class="line">Out[<span class="number">14</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: b</span><br><span class="line">Out[<span class="number">15</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求ab的交集</span></span><br><span class="line">In [<span class="number">17</span>]: a &amp; b</span><br><span class="line">Out[<span class="number">17</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求ab的并集</span></span><br><span class="line">In [<span class="number">16</span>]: a | b</span><br><span class="line">Out[<span class="number">16</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#在a中但不在b中的元素</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a-b</span><br><span class="line">Out[<span class="number">18</span>]: &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#不在a中不在b中</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a ^ b</span><br><span class="line">Out[<span class="number">19</span>]: &#123;<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#添加元素</span></span><br><span class="line">In [<span class="number">28</span>]: a.add(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: a</span><br><span class="line">Out[<span class="number">29</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#移除元素</span></span><br><span class="line">In [<span class="number">30</span>]: a.remove(<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a</span><br><span class="line">Out[<span class="number">31</span>]: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.4</title>
    <url>/2021/02/23/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.4/</url>
    <content><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>上面我们谈了数据类型，这篇我们该看下数据结构</p>
<p>Python中的数据结构有list(列表)，dict（字典），set（集合）, tuple（元祖）</p>
<p>可以对元素进行修改的数据结构有：list(列表)，dict（字典），set（集合）</p>
<p>不可以对元素进行修改的数据结构有： tuple（元祖）</p>
<h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><ul>
<li><p>列表是最常用的，也是最基本的数据结构。</p>
</li>
<li><p>使用<code>[]</code>来生成一个列表</p>
</li>
<li><p>列表的元素可以是，字符串，数字等基本数据类型，也可以是列表，元祖等其余数据结构</p>
</li>
<li><p>列表是有序的，你可以正向使用，也可以反向使用。</p>
</li>
<li><p>列表可以进行的基本操作有索引，切片，加，乘，检查成员。</p>
</li>
</ul>
<p><img src="/Users/sujiaqi/Pictures/Typora/python-list.png" alt="查看源图像"></p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">  </span><br><span class="line">In [<span class="number">35</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out[<span class="number">35</span>]: <span class="built_in">list</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: b=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: c=[a,b]</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: print(b)</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: print(c)</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#列表索引操作</span></span><br><span class="line">In [<span class="number">12</span>]: a[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: a[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a[-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: a[-<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">15</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#列表加操作</span></span><br><span class="line">In [<span class="number">16</span>]: d = a + b</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: print(d)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#列表乘操作</span></span><br><span class="line">In [<span class="number">18</span>]: a*<span class="number">3</span></span><br><span class="line">Out[<span class="number">18</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: c*<span class="number">2</span></span><br><span class="line">Out[<span class="number">24</span>]: [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查成员</span></span><br><span class="line">In [<span class="number">25</span>]: <span class="number">1</span> <span class="keyword">in</span> a</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: <span class="number">7</span> <span class="keyword">in</span> a</span><br><span class="line">Out[<span class="number">26</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表切片</span></span><br><span class="line">In [<span class="number">27</span>]: f = a*<span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: print(f)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment"># 一般用法</span></span><br><span class="line">In [<span class="number">29</span>]: f[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: f[<span class="number">3</span>:]</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: f[:-<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">32</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line"> <span class="comment"># 步长</span></span><br><span class="line"><span class="comment"># 从f[1]到f[4]，每隔两位抽取一个元素</span></span><br><span class="line">In [<span class="number">34</span>]: f[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">34</span>]: [<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>



<h3 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h3><ul>
<li><p>元祖是不可修改的</p>
</li>
<li><p>使用<code>( )</code>来创造一个元祖</p>
</li>
<li><p>也可以根据索引来使用元素，或切片</p>
</li>
<li><p>不可以修改元祖中的值，但元祖之间可以进行连接</p>
</li>
</ul>
<p><strong>实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元祖</span></span><br><span class="line">In [<span class="number">41</span>]: tup1=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: tup2=(tup1,tup1)</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: tup2</span><br><span class="line">Out[<span class="number">43</span>]: ((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: <span class="built_in">type</span>(tup1)</span><br><span class="line">Out[<span class="number">44</span>]: <span class="built_in">tuple</span></span><br><span class="line"><span class="comment"># 元祖切片</span></span><br><span class="line">In [<span class="number">45</span>]: tup1[:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">45</span>]: (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 根据index来使用元祖元素</span></span><br><span class="line">In [<span class="number">47</span>]: tup1[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">47</span>]: <span class="number">2</span></span><br><span class="line"><span class="comment"># 元祖连接</span></span><br><span class="line">In [<span class="number">48</span>]: tup3 = tup1 + tup2</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: tup3</span><br><span class="line">Out[<span class="number">49</span>]: (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.6</title>
    <url>/2021/02/25/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.6/</url>
    <content><![CDATA[<h3 id="条件控制"><a href="#条件控制" class="headerlink" title="条件控制"></a>条件控制</h3><p>简单说下就是<code>if</code>判断</p>
<p><img src="https://i.loli.net/2021/02/25/EHfGhODU4zk9mqx.jpg" alt="cainiaojiaocheng1"></p>
<p>简单来说下基本形式就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件一：</span><br><span class="line">	执行动作一</span><br><span class="line"><span class="keyword">elif</span> 条件二：</span><br><span class="line">	执行动作二：</span><br><span class="line"><span class="keyword">else</span> 条件三：</span><br><span class="line">	执行动作三</span><br></pre></td></tr></table></figure>

<p>如果你只需要判断一种条件那么：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件一：</span><br><span class="line">	执行动作一</span><br></pre></td></tr></table></figure>

<p>甚至不需要else</p>
<p>需要注意的是  <code>if</code>判断条件后面需要加<code>：</code></p>
<p><code>if</code>常和<code>while</code>以及<code>for</code>联用</p>
<h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从一个列表中用判断某个数字是否存在</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> a:</span><br><span class="line">	print(<span class="string">&#x27;1 in a&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 判断一个列表中特定数字是否存在</span></span><br><span class="line"><span class="comment"># 创建一个列表，包含`1,2,3,4`四个元素</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment"># 遍历列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="comment">#判断列表元素是否等于1</span></span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">		print(<span class="string">&#x27;1 in a&#x27;</span>)</span><br><span class="line"><span class="comment">#判断列表元素是否等于2	</span></span><br><span class="line">	<span class="keyword">elif</span> <span class="number">1</span> &lt; i &lt;  <span class="number">3</span>:</span><br><span class="line">		print(<span class="string">&#x27;2 in a&#x27;</span>)</span><br><span class="line"><span class="comment">#如果列表元素既不等于1也不等于2</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		print(<span class="string">&#x27;this &gt;= 3&#x27;</span>)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>当然列表也可以嵌套，这取决你的解决问题的复杂程度</p>
<p><strong>你当然可以按照下述操作进行使用</strong></p>
<p><strong>但是需要注意</strong></p>
<p><strong>当你的问题达到一个很复杂的程度的时候，使用嵌套方式会加大你的记忆程度，以及程序的使用难度以及设计难度</strong></p>
<p><strong>而且会使问题的解决方式实际上变得更为复杂，这取决于你的记忆以及编码水平</strong></p>
<p><strong>同时在这里你应该注意缩进符对python的影响，只要有一个缩进有问题，此程序便不可运行</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">    ...:</span><br><span class="line">    ...: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    ...:	<span class="keyword">if</span> <span class="number">1</span>&lt;i&lt;<span class="number">4</span>:</span><br><span class="line">    ...:		<span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">    ...:			print(<span class="string">&#x27;this is 1 and this &lt; 4&#x27;</span>)</span><br><span class="line">    ...:		<span class="keyword">elif</span> i == <span class="number">2</span>:</span><br><span class="line">    ...:			print(<span class="string">&#x27;this is 2 and this &lt; 4&#x27;</span>)</span><br><span class="line">    ...:	<span class="keyword">if</span> i &gt; <span class="number">4</span>:</span><br><span class="line">    ...:		<span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">    ...:			print(<span class="string">&#x27;this is 5 and this &gt; 4&#x27;</span>)</span><br><span class="line">    ...:		<span class="keyword">elif</span> i == <span class="number">6</span>:</span><br><span class="line">    ...:			print(<span class="string">&#x27;this is 6 and this &gt; 4&#x27;</span>)</span><br><span class="line">    ...:		<span class="keyword">else</span>:</span><br><span class="line">    ...:			print(<span class="string">&#x27;this is others&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">this <span class="keyword">is</span> <span class="number">2</span> <span class="keyword">and</span> this &lt; <span class="number">4</span></span><br><span class="line">this <span class="keyword">is</span> <span class="number">5</span> <span class="keyword">and</span> this &gt; <span class="number">4</span></span><br><span class="line">this <span class="keyword">is</span> <span class="number">6</span> <span class="keyword">and</span> this &gt; <span class="number">4</span></span><br><span class="line">this <span class="keyword">is</span> others</span><br><span class="line">this <span class="keyword">is</span> others</span><br><span class="line">this <span class="keyword">is</span> others</span><br></pre></td></tr></table></figure>



<p><code>if</code>中常用的一些判断符号</p>
<table>
<thead>
<tr>
<th align="left">判断符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;</code></td>
<td align="left">小于</td>
</tr>
<tr>
<td align="left"><code>&lt;=</code></td>
<td align="left">小于或等于</td>
</tr>
<tr>
<td align="left"><code>&gt;</code></td>
<td align="left">大于</td>
</tr>
<tr>
<td align="left"><code>&gt;=</code></td>
<td align="left">大于或等于</td>
</tr>
<tr>
<td align="left"><code>==</code></td>
<td align="left">等于，比较两个值是否相等</td>
</tr>
<tr>
<td align="left"><code>!=</code></td>
<td align="left">不等于</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.7</title>
    <url>/2021/02/26/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.7/</url>
    <content><![CDATA[<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环，是最常用的命令，和判断语句一样，一般情况下，我们将问题或者实际情况进行拆解，分类，然后使用循环以及判断来寻找潜在的解。</p>
<p>python的循环有两个<code>for</code>以及<code>while</code></p>
<p>我们先来看<code>for</code>循环</p>
<p><code>for</code>循环可以遍历字符串，列表，字典等等数据结构。</p>
<p>一般的情况就是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">	print(i)</span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">In [<span class="number">1</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">In [<span class="number">3</span>]: a = <span class="string">&#x27;1,2,3,4&#x27;</span></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line">,</span><br><span class="line"><span class="number">2</span></span><br><span class="line">,</span><br><span class="line"><span class="number">3</span></span><br><span class="line">,</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line"><span class="comment"># 字典会比较复杂，你可以遍历keys，value以及（key，value）</span></span><br><span class="line"><span class="comment"># 我们来遍历key+value</span></span><br><span class="line">In [<span class="number">6</span>]: a = &#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line">   ...: <span class="keyword">for</span> i <span class="keyword">in</span> a.items():</span><br><span class="line">   ...:     print(i)</span><br><span class="line">   ...:</span><br><span class="line">(<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>或者你可以通过索引来进行遍历，最常见是遍历列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">7</span>]: a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">   ...:     print(a[i])</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 让我们来看看整个过程发生了什么</span></span><br><span class="line"><span class="comment"># 当然是用代码来进行表示</span></span><br><span class="line">In [<span class="number">9</span>]: a</span><br><span class="line">Out[<span class="number">9</span>]: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="comment">#获取列表长度</span></span><br><span class="line">In [<span class="number">10</span>]: <span class="built_in">len</span>(a)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">4</span></span><br><span class="line"><span class="comment">#使用range函数创建一个整数列表</span></span><br><span class="line">In [<span class="number">11</span>]: <span class="built_in">range</span>(<span class="number">4</span>)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">#使用for来遍历这个整数列表</span></span><br><span class="line">In [<span class="number">12</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ...:     print(i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment">#使用索引来遍历列表a中的所有元素</span></span><br><span class="line">In [<span class="number">13</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    ...:     print(a[i])</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>让我们再来看看<code>else</code></p>
<p><code>else</code>在循环中也可以使用</p>
<p>我们先来看一个简单的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: <span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">    ...: <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    ...:     print(x)</span><br><span class="line">    ...: <span class="keyword">else</span>:</span><br><span class="line">    ...:     print(<span class="string">&quot;else&quot;</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在上例中，我们先使用<code>for</code>遍历了<code>x</code>，执行完成之后，程序执行<code>else</code>语句，打印出<code>print</code></p>
<p>是不是感觉好像<code>else</code>没有什么用处</p>
<p>就仿佛。。。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">    ...: <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">    ...:     print(x)</span><br><span class="line">    ...: print(<span class="string">&quot;else&quot;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="keyword">else</span></span><br></pre></td></tr></table></figure>

<p>恩。。。确实是，我们再来看一个官方例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    ...:         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">    ...:             print( n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n/x)</span><br><span class="line">    ...:             <span class="keyword">break</span></span><br><span class="line">    ...:     <span class="keyword">else</span>:</span><br><span class="line">    ...:         print(n, <span class="string">&#x27;是一个素数&#x27;</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">2</span> 是一个素数</span><br><span class="line"><span class="number">3</span> 是一个素数</span><br><span class="line"><span class="number">4</span> 等于 <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span> 是一个素数</span><br><span class="line"><span class="number">6</span> 等于 <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span> 是一个素数</span><br><span class="line"><span class="number">8</span> 等于 <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line"><span class="number">9</span> 等于 <span class="number">3</span> * <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<p>整个过程发生了什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们首先使用range函数创造了一个整数列表</span></span><br><span class="line">In [<span class="number">23</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     print(n)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="comment"># 然后我们使用range函数创建了，从2到n的一个整数列表</span></span><br><span class="line">In [<span class="number">26</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     print(<span class="built_in">range</span>(<span class="number">2</span>,n))</span><br><span class="line">    ...:</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">range</span>(<span class="number">2</span>, <span class="number">9</span>)</span><br><span class="line"><span class="comment"># 随后我们来检查是否n处以x等于0</span></span><br><span class="line">In [<span class="number">28</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    ...:         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">    ...:            print( <span class="string">&#x27;check&#x27;</span>,n,<span class="string">&#x27;/&#x27;</span>,x,<span class="string">&#x27;=0&#x27;</span>)</span><br><span class="line">    ...:            print( n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n/x)</span><br><span class="line">    ...:</span><br><span class="line">check <span class="number">4</span> / <span class="number">2</span> =<span class="number">0</span></span><br><span class="line"><span class="number">4</span> 等于 <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line">check <span class="number">6</span> / <span class="number">2</span> =<span class="number">0</span></span><br><span class="line"><span class="number">6</span> 等于 <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line">check <span class="number">6</span> / <span class="number">3</span> =<span class="number">0</span></span><br><span class="line"><span class="number">6</span> 等于 <span class="number">3</span> * <span class="number">2.0</span></span><br><span class="line">check <span class="number">8</span> / <span class="number">2</span> =<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 等于 <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line">check <span class="number">8</span> / <span class="number">4</span> =<span class="number">0</span></span><br><span class="line"><span class="number">8</span> 等于 <span class="number">4</span> * <span class="number">2.0</span></span><br><span class="line">check <span class="number">9</span> / <span class="number">3</span> =<span class="number">0</span></span><br><span class="line"><span class="number">9</span> 等于 <span class="number">3</span> * <span class="number">3.0</span></span><br><span class="line"><span class="comment"># 如果我们发现了n除以x等于0</span></span><br><span class="line"><span class="comment"># 例如 check 6 / 2 =0</span></span><br><span class="line"><span class="comment"># 那么打印出6 等于 2 * 3.0</span></span><br><span class="line"><span class="comment"># for x in range(2, n) 被break掉，else不会执行</span></span><br><span class="line">In [<span class="number">29</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    ...:         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">    ...:             print( n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n/x)</span><br><span class="line">    ...:             <span class="keyword">break</span></span><br><span class="line">    ...:</span><br><span class="line"><span class="number">4</span> 等于 <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line"><span class="number">6</span> 等于 <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line"><span class="number">8</span> 等于 <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line"><span class="number">9</span> 等于 <span class="number">3</span> * <span class="number">3.0</span></span><br><span class="line"><span class="comment"># 如果我们没有发现n除以x等于0</span></span><br><span class="line"><span class="comment"># 那么执行else</span></span><br><span class="line"><span class="comment"># 打印出3 是个素数</span></span><br><span class="line">In [<span class="number">32</span>]: <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    ...:     <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n):</span><br><span class="line">    ...:         <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">    ...:             print( n, <span class="string">&#x27;等于&#x27;</span>, x, <span class="string">&#x27;*&#x27;</span>, n/x)</span><br><span class="line">    ...:             <span class="keyword">break</span></span><br><span class="line">    ...:     <span class="keyword">else</span>:</span><br><span class="line">    ...:         print(n, <span class="string">&#x27;是个素数&#x27;</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">2</span> 是个素数</span><br><span class="line"><span class="number">3</span> 是个素数</span><br><span class="line"><span class="number">4</span> 等于 <span class="number">2</span> * <span class="number">2.0</span></span><br><span class="line"><span class="number">5</span> 是个素数</span><br><span class="line"><span class="number">6</span> 等于 <span class="number">2</span> * <span class="number">3.0</span></span><br><span class="line"><span class="number">7</span> 是个素数</span><br><span class="line"><span class="number">8</span> 等于 <span class="number">2</span> * <span class="number">4.0</span></span><br><span class="line"><span class="number">9</span> 等于 <span class="number">3</span> * <span class="number">3.0</span></span><br></pre></td></tr></table></figure>

<p>其实，写到这里我也有些困了，<code>for </code>和<code>else</code>一起搭的用法确实有些反人类，看看官方的这个例子，也就是在整体的<code>for</code>循环中，又分为两个部分，一个用于判断，如果判断成功则<code>else</code>不被执行，否则执行<code>else</code></p>
<p>好了，今天就到这里.</p>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.8</title>
    <url>/2021/02/28/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.8/</url>
    <content><![CDATA[<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>另外一个常用的循环语句是<code>while</code>,在<code>while</code>语句中只要满足条件，就可以一直循环</p>
<p>基本形式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 判断语句：</span><br><span class="line">	执行语句</span><br></pre></td></tr></table></figure>

<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = <span class="number">0</span></span><br><span class="line">In [<span class="number">2</span>]: b = <span class="number">10</span></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">while</span> a &lt; b :</span><br><span class="line">   ...:     print(a)</span><br><span class="line">   ...:     a = a + <span class="number">1</span></span><br><span class="line">   ...: print(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当然利用这个特性，你也可以使用一个死循环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="keyword">while</span> a == b:</span><br><span class="line">    ...:     print(a)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 此时你可以关闭终端，或者ctrl + c来进行终止</span></span><br></pre></td></tr></table></figure>

<p>当然<code>while</code>也可以与<code>else</code>联用，个人理解在<code>while</code>执行完成之后，不符合判段条件时，便可以执行<code>else</code>语句</p>
<p>基本形式为</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 判断条件:</span><br><span class="line"></span><br><span class="line">	执行语句</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line"></span><br><span class="line">	执行语句</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: b = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: <span class="keyword">while</span> a &lt; b :</span><br><span class="line">    ...:     print(a)</span><br><span class="line">    ...:     a = a + <span class="number">1</span></span><br><span class="line">    ...: <span class="keyword">else</span>:</span><br><span class="line">    ...:     print(<span class="string">&#x27;jump&#x27;</span>)</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">jump</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>Python每日一谈｜No.9</title>
    <url>/2021/02/28/python-every-day/Python%E6%AF%8F%E6%97%A5%E4%B8%80%E8%B0%88%EF%BD%9CNo.9/</url>
    <content><![CDATA[<h3 id="循环中的一些关键词"><a href="#循环中的一些关键词" class="headerlink" title="循环中的一些关键词"></a>循环中的一些关键词</h3><p>在上面我们已经说了<code>else</code></p>
<p>现在那么只有三个关键词<code>break, continue,pass</code></p>
<ol>
<li><p><code>break</code></p>
<p><code>break</code> 用于打破循环，想到了悟空，hhh，在循环中，当值满足某个条件值，可以使用<code>break</code>打破此循环，避免执行后续语句，减少计算量</p>
<p>一般形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: a = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line">    ...: <span class="keyword">for</span>   i  <span class="keyword">in</span> a:</span><br><span class="line">    ...: 	<span class="keyword">if</span> i == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">    ...:		print(<span class="string">&#x27;find d and break&#x27;</span>)</span><br><span class="line">    ...:		<span class="keyword">break</span></span><br><span class="line">    ...:	print(<span class="string">&#x27;find&#x27;</span>,i)</span><br><span class="line">    ...: print(<span class="string">&#x27;finished&#x27;</span>)</span><br><span class="line">find a</span><br><span class="line">find b</span><br><span class="line">find c</span><br><span class="line">find d <span class="keyword">and</span> <span class="keyword">break</span></span><br><span class="line">finished</span><br></pre></td></tr></table></figure></li>
<li><p><code>continue</code>用于跳过当前的循环</p>
<p>当满足你的判断条件时，使用<code>continue</code>可以跳过本次循环，进入下一循环</p>
<p>我们来看一个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我们使用continue时</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: a = <span class="string">&#x27;abcdefg&#x27;</span> </span><br><span class="line">    ...: print(<span class="string">&#x27;continue&#x27;</span>) </span><br><span class="line">    ...: <span class="keyword">for</span> i <span class="keyword">in</span> a: </span><br><span class="line">    ...:     <span class="keyword">if</span> i == <span class="string">&#x27;c&#x27;</span>: </span><br><span class="line">    ...:         <span class="keyword">continue</span> </span><br><span class="line">    ...:     print(<span class="string">&#x27;find &#x27;</span>,i) </span><br><span class="line">    ...:                                                                                                                                                   </span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">find  a</span><br><span class="line">find  b</span><br><span class="line">find  d</span><br><span class="line">find  e</span><br><span class="line">find  f</span><br><span class="line">find  g</span><br><span class="line"><span class="comment"># 可以看出我们跳过了c进行了后续的循环</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当我们使用break是</span></span><br><span class="line">In [<span class="number">62</span>]: print(<span class="string">&#x27;break&#x27;</span>)</span><br><span class="line">    ...: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    ...:     <span class="keyword">if</span> i == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">    ...:         <span class="keyword">break</span></span><br><span class="line">    ...:     print(<span class="string">&#x27;find &#x27;</span>,i)</span><br><span class="line">    ...:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">find  a</span><br><span class="line">find  b</span><br><span class="line"><span class="comment"># 可以看出当遇到break时，循环直接被打破</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>pass</code></p>
<p>pass是空语句，不做任何事情，你可以把它当作一个为了保证程序结构完整性而创造出来的词</p>
<p>只是为了占个位置，看起来顺眼</p>
<p>例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">63</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    ...:     <span class="keyword">if</span> i == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">    ...:         <span class="keyword">pass</span></span><br><span class="line">    ...:     print(<span class="string">&#x27;find &#x27;</span>,i)</span><br><span class="line">    ...:</span><br><span class="line">find  a</span><br><span class="line">find  b</span><br><span class="line">find  c</span><br><span class="line">find  d</span><br><span class="line">find  e</span><br><span class="line">find  f</span><br><span class="line">find  g</span><br><span class="line"><span class="comment"># 可以看出当我们使用pass时，实际上没有发生任何变化，程序会正常执行，循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者下面一个例子</span></span><br><span class="line">In [<span class="number">38</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> a: </span><br><span class="line">    ...:     <span class="keyword">if</span> i == <span class="string">&#x27;c&#x27;</span>: </span><br><span class="line">    ...:         <span class="keyword">pass</span> </span><br><span class="line">    ...:     <span class="keyword">else</span>: </span><br><span class="line">    ...:         print(i,<span class="string">&#x27;is not c&#x27;</span>) </span><br><span class="line"><span class="comment"># 当我们在使用pass时，程序不执行任何操作，但当条件不是‘c’时，程序执行print操作                                                                                                                                               </span></span><br><span class="line">a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">b <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">d <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">e <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">f <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">g <span class="keyword">is</span> <span class="keyword">not</span> c</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python每日一谈</category>
      </categories>
  </entry>
  <entry>
    <title>PythonEveryDay</title>
    <url>/2021/02/22/python-every-day/README/</url>
    <content><![CDATA[<p>Hi, 大家好。</p>
<blockquote>
<p>开这个专栏是因为大家想学，而且，基本不需要更新的问题。</p>
<p>我们会从基础开始进行教学，继而进行安装，包使用，编程等等。</p>
<p>由于是总结以及教学方面，我会参考各种教程，如有引用，必定开源(本教程遵循MIT协议)。</p>
<p>当然，我们的实例重点是偏向于python使用与结构生物学，CADD，化学信息学等方面的使用。</p>
<p>（毕竟爬PubChem，也算爬虫的一种）</p>
<p>最终会提供几个实例，作为结尾，说到这里，又应该开一个仓库了。</p>
<p>(Typora + Gitee)[<a href="https://zhuanlan.zhihu.com/p/349427506]%E8%87%AA%E5%8A%A8%E4%B8%8A%E4%BC%A0%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F%F0%9F%98%8E">https://zhuanlan.zhihu.com/p/349427506]自动上传了解一下？😎</a></p>
</blockquote>
<p>祝大家学习愉快！</p>
]]></content>
  </entry>
  <entry>
    <title>2020 年FDA药物总览</title>
    <url>/2021/02/24/paper/2020%20%E5%B9%B4FDA%E8%8D%AF%E7%89%A9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>Cite:<a href="https://www.nature.com/articles/d41573-021-00002-0">https://www.nature.com/articles/d41573-021-00002-0</a></p>
</blockquote>
<p>FDA在2020年批准了53种新药，这是20年以来批准的第二高峰，仅低于2018年批准的59种药物。</p>
<p>2020年批准的药物是过去十年内批准的两倍多。</p>
<p>延续最近几年的趋势，癌症产品仍然站住主导地位。医药行业对癌症的关注比以往更为显著。FDA在2020年批准了18种产品（占总体34%），近五年内癌症产品占据25％。神经类药物（Neurology products ）占据第二位，有8种药物获批（占总体15%）。传染病类药物排在第三位，有6种药物获批（占据总体的11%）。</p>
<p>在治疗方式方面，基于抗体和基于寡核苷酸的疗法（antibody-based and oligonucleotide-based therapeutics）继续拓宽治疗领域。基于抗体治疗的12种药物获得批准，与2018年是此类产品的历史新高。过去五年内每年批准10种。相比之下，2006年至2010年期间，FDA每年仅批准两种新抗体。</p>
<p>这同样也是一个突破性的一年，在孤儿药，首要疗法，突破性疗法，加速类疗法（orphan and breakthrough designations,accelerated approvals）。FDA批准31种产品（58%）用于治疗罕见疾病，高于5年平均水平46%。批准了22种（42%）具有突破性疗法的产品，这些产品可能比其他可用于治疗严重疾病的产品有实质性的改进。这一比例高于5年平均水平28%。根据替代终点的改进，它批准了12种（23%）的加速疗法，高于过去5年的平均水平16%。然而，对于那些在安全性或有效性方面有显著改善的产品，优先审查（Priority reviews）的次数减少了。</p>
<p>EvaluatePharma的销售预测显示，到2026年，有11种产品有望实现畅销（表3）。其中四款年销售额可能超过20亿美元。</p>
<p>但波士顿咨询集团（Boston Consulting Group）的一项分析显示，新获批药物的整体财务未来仍低于平均水平。他们的预测表明，2020年新批准药物的平均预期峰值销售额为7亿美元，中位数为4亿美元。这低于平均水平的13亿美元和5亿美元的中位数。</p>
<img src="https://i.loli.net/2021/02/24/gQU7k8rBWoubs2Y.png" alt="image-20210224222253753" style="zoom:50%;" />

<h3 id="抗体类药物在上升"><a href="#抗体类药物在上升" class="headerlink" title="抗体类药物在上升"></a>抗体类药物在上升</h3><p>抗体类药物共有12项被批准。例如，针对新靶点的抗体偶联类药物（ADC）获得了两项批准。</p>
<p>Immunomedics公司的sacituzumab govitecan是一种治疗三阴性乳腺癌的TROP2靶向ADC。该公司在2018年首次向FDA提交了这种治疗药物，但该机构在2019年拒绝了。Immunomedics当时表示，推迟是因为生产问题，该公司当年重新提交了该药。</p>
<p><a href="https://www.immunomedics.com/">Immunomedics</a> 公司的 sacituzumab govitecan是一种治疗乳腺癌的TROP2靶向性ADC药物。该公司在2018年首次向FDA提交了这种治疗药物，但在2019年被拒绝。Immunomedics在当时表示，被拒绝是因为生产问题，该公司在当年重新提交了该药。之后FDA批准了ADC，Gilead以210亿美元收购了Immunomedics，主要是为了获得这种药物。分析师预测，到2026年，sacituzumab govitecan的年销售额将达到<strong>24亿美元</strong>。</p>
<p>与此同时，葛兰素史克在靶向BCMA癌症疗法的激烈竞争中取得了先发优势。</p>
<p>BCMA在多发性骨髓瘤细胞上过度表达。可靠的生物验证实验、有限的体外毒性风险以及强大的商业潜力都加大了各界对BCMA的兴趣。药物研发人员正在开发CAR-T疗法、ADC、双特异性抗体和其他BCMA靶向疗法。</p>
<p>靶向BCMA的CAR-T治疗手段已显示出惊人的疗效，但这些疗法可能面临制造和销售瓶颈。葛兰素史克转而选择了一种ADC belantamab mafodotin（一种能对病人产生广泛疗效的药物）。分析师预测，到2026年，年销售额将达到13亿美元。</p>
<p>迄今为止，FDA已经批准了9种ADC类药物。在过去两年内，FDA批准了五项。目前仍有两个ADC正在接受FDA的审查，并将在2021年做出决定。</p>
<p>2020年，针对病毒的单克隆抗体（mAb）产品也获得了两次批准。这些药物Regeneron的atoltivimab、odesivimab和maftivimab（鸡尾酒,算作单一批准）和Ridgeback的ansuvimab，都是针对于埃博拉病毒。</p>
<p>临床上有多种针对SARS-CoV-2的单克隆抗体。其他一些新型单克隆抗体正在研发，这将会是一场激烈的竞争。</p>
<p>Lundbeck的eptinezumab是针对CGRP受体的第四种抗体疗法。Biohaven的rimegepant也在2020年获得批准，是第二个被批准的CGRP受体小分子拮抗剂。</p>
<img src="https://i.loli.net/2021/02/25/lhfmwECO6YMUySG.png" alt="image-20210225222429973" style="zoom:50%;" />

<h3 id="小分子大影响"><a href="#小分子大影响" class="headerlink" title="小分子大影响"></a>小分子大影响</h3><p>小分子也在开辟新的治疗领域。罗氏和 Genentech的risdiplam展示了小分子结合RNA靶点的潜力。脊髓性肌萎缩症（SMA）是一种罕见的神经肌肉疾病，可导致运动神经元的进行性破坏。它是由SMN1缺陷引起的，SMN1编码存活运动神经元（SMN）蛋白。2016年，FDA批准了Biogen和Ionis的nusinersen，这是第一种针对SMA的疾病改良疗法。</p>
<p>Risdiplam是Genentech与SMA基金会和PTC Therapeutics合作开发的一种小分子药物。nusinersen是在临床上给药的，而risdiplam是口服的，可以直接在家里进行给药。SMA是近年来创新的一个比较典型的案例。除了nusinersen之外，2019年，FDA还批准了诺华的Semnogene abeparvovec的基因疗法。</p>
<p>分析人士预测，到2026年，risdiplam的年销售额将达到20亿美元，这凸显了小分子药物与罕见疾病的紧急治疗方式竞争的潜力。其他公司也在用小分子靶向RNA的策略，专注于剪接调控以外的机会。</p>
<p>为了控制COVID-19大流行，FDA依靠紧急使用授权（EUAs）来加速一些潜在有用的COVID-19疫苗和候选药物的快速推广。这些授权适用于“可能有效”的产品，这是一种比管理局用于批准的“有效性”标准更低的证据水平。然而，EUA并不是获得FDA批准的长期药品，公司需要继续开发他们的产品以便进行全面的监管审查。</p>
<p>值得注意的是，12月份，就在SARS-CoV-2病毒出现一年之后，两个候选疫苗获得了EUAs批准。辉瑞和BioNTech的BNT162b2和mRNA-1273都是mRNA疫苗。辉瑞和Moderna都计划在2021年将疫苗提交全面审批，为年底前获得批准铺平道路。</p>
<p>Gilead的remdesivir显示了EUA转化的速度有多快。FDA5月份首次批准了瑞德西韦（remdesivir）的使用，并于10月份完整审批了该药。</p>
<p>该机构还对两种新的抗体产品进行了EUAs授权：Regeneron的casirivimab和imdevimab组合，以及礼来的bamlanivimab。</p>
<p><strong>EUAs授权也彰显了药物快速开发的危险，并引发了对监管过程政治化的担忧。</strong>最值得注意的是，FDA在3月份批准了抗疟药物氯喹和羟基氯喹的EUA，尽管几乎没有证据表明它们对COVID-19有效。而在6月份撤销了EUA，并指出这些药物“不太可能有效治疗COVID-19”。</p>
<img src="https://i.loli.net/2021/02/25/hMxsJoU4YdVzp1e.png" alt="image-20210225222507881" style="zoom:50%;" />

<h3 id="与激酶一起前进"><a href="#与激酶一起前进" class="headerlink" title="与激酶一起前进"></a>与激酶一起前进</h3><p>小分子激酶抑制剂也在发展壮大。FDA去年批准了8种激酶抑制剂，是肿瘤药物批准量的一半。尽管在激酶领域存在竞争，但具有正确药理特性的药物仍有很好的前景。例如，随着FDA批准Blueprint Medicines的PDGFR抑制剂avapritinib治疗胃肠道间质瘤（GISTs），该公司将接手诺华公司的小分子激酶抑制物。</p>
<p>伊马替尼是少数具有抗PDGFR活性的多激酶抑制剂之一，已用于GIST患者。然而，根据Blueprint的数据，6%的患者有PDGFRA外显子有18个突变，对伊马替尼的反应特别差。基于此，Blueprint开发了avapritinib。该药物是首个被批准用于治疗携带PDGFRA外显子18突变的GIST患者的方法。如果美国每年约有3000例GIST病例，那么这相当于每年约有180名潜在的患者需要avapritinib进行治疗。分析师预测，到2026年，该药的销售额将达到10亿美元。</p>
<p>礼来的首个RET-选择性激酶抑制剂，selpercatinib获的批准。多激酶抑制剂如赛诺菲的vandetanib和艾塞力克斯的cabozantinib对RET有活性，但这些药物的安全性和持久性被认为是有限的，至少部分是由于它们对其他激酶的活性。礼来公司在2019年收购洛索公司的交易中获得了selpercatinib。selpercatinib首先被批准用于非小细胞肺癌和两种甲状腺癌。。FDA还批准了Blueprint和罗氏RET选择性抑制剂pralsetinib治疗非小细胞肺癌。</p>
<p><img src="https://i.loli.net/2021/02/26/Q6SfDOeo7brTL5t.png" alt="image-20210225222547885"></p>
<h2 id="有趣的时代"><a href="#有趣的时代" class="headerlink" title="有趣的时代"></a>有趣的时代</h2><p>吉利德公司的remdesivir首次获得了治疗COVID-19的批准，以前所未有的速度完成了其研发和监管里程碑。</p>
<p>Remdesivir是一种RNA聚合酶抑制剂，它模拟RNA核苷酸来阻止病毒RNA的合成。这种小分子最初被发现用于丙型肝炎和呼吸道合胞病毒，在2014-2016年西非爆发埃博拉疫情期间，它被重新用作埃博拉的潜在治疗药物。这些试验帮助建立了雷姆德西韦的安全性数据库，但被证明是无效的。</p>
<p>随着SARS-CoV-2的出现，导致COVID-19的病毒，Gilead很快将remdesivir推进了试验。remdesivir首次试验于2月开始。到5月，FDA已经批准了它的紧急使用授权，允许分发未经批准的候选药物。10月，FDA基于一个NIH赞助的试验和两个Gilead赞助的试验的基础上批准了该药。然而，世界卫生组织领导的一项大型多组试验发现，“对COVID-19住院患者几乎没有影响”。</p>
<p>分析师目前预测，2021年remdesivir的最高销售额将接近15亿美元，到2025年将降至5亿美元。但这些预测下降得很快，说明了潜在的缺陷。在2020年6月，一些分析师预测年销售额最高可达70亿美元。FDA也批准了紧急情况使用其他几种新型COVID-19候选疫苗的授权，包括疫苗和治疗性抗体（框1）。</p>
<p>Epizyme的tazemetostat是EZH2的第一个抑制剂，它使组蛋白甲基化以调节转录活性。FDA批准tazemetostat治疗上皮样肉瘤。</p>
<p>Eiger BioPharmaceuticals的lonafarnib是first-in-clas的farnesyltransferase抑制剂。几十年前，药物研发人员一直致力于这一目标的研究，而艾格的研究是针对一种罕见的早衰症，称为Hutchinson-Gilford早衰综合征（Hutchinson-GilfordProgeria syndrome）。</p>
<p>Trevena的μ-阿片受体激动剂oliceridine，被批准用于中重度急性疼痛。这种药物曾被誉为GPCR激动剂的典型代表，这种药物激活GPCR的一个子集受体的信号通路。特雷维纳曾希望oliceridine比传统的阿片受体激动剂安全性更好，但该机构表示oliceridine的安全性“与其他阿片类似”。</p>
<p>吉利德的brexucabtagene autoleucel获批标志着CD19靶向CAR-T细胞治疗的第三个绿灯。这是第一个被批准用于套细胞淋巴瘤的CAR-T细胞疗法。</p>
<p><img src="/Users/sujiaqi/Pictures/Typora/BbhWv1wX7zJtOHm.png" alt="image-20210226000831191"></p>
<h2 id="不全是好消息"><a href="#不全是好消息" class="headerlink" title="不全是好消息"></a>不全是好消息</h2><p>一些药物开发商在2020年遭遇了挫折，收到了FDA的完整回复函（表4）。</p>
<p>AbbVie、Allergan和Molecular Partners的新生血管(湿性)年龄相关性黄斑变性(nAMD)药物abicipar pegol的生物制剂许可申请（BLA）遭到该机构的拒绝这是DARPin（designed ankyrin repeat protein，设计锚蛋白重复序列蛋白）的首次申请，DARPin是一种低分子量的生物形式，旨在与单克隆抗体竞争。但FDA以眼内炎症为由拒绝了该候选药物。</p>
<p>FDA拒绝了Gilead的JAK抑制剂filgotinib治疗类风湿性关节炎。分析师此前预测，这种消炎药的最高销售额接近15亿美元。但是FDA要求提供更多的安全性数据。EMA在2020年批准了filgotinib。</p>
<p>FDA还拒绝了诺华和的inclisiran治疗高脂血症，inclisiran是一种能降低PCSK9产量的小干扰RNA制剂。如果获得批准，这种基于寡核苷酸的药物将与两种FDA批准的针对PCSK9的单抗竞争。这些单抗每2-4周给药一次，inclisiran每年给药两次。诺华于2019年斥资97亿美元收购了这家医药公司，以获得这一治疗药物的使用权，并获得了阿林制药公司（Alnylam Pharmaceuticals）的许可。诺华说，拒绝的原因是因为“未解决设施检查相关条件”。EMA于2020年批准了Incisiran。</p>
<p>Intercept的法尼类 X 受体激动剂阿苯胆酸（obeticholic acid）于2016年首次被FDA批准用于原发性胆管炎，因此对非酒精性脂肪性肝炎（NASH）的补充批准不符合FDA新批准名单的要求。但人们希望这种药物能够获得NASH的批准，这一迹象在过去十年中吸引了许多药物研发人员。然而，FDA拒绝了这一申请，指出“预期的益处……仍然不确定，而且还不足以超过潜在的风险。”</p>
<p><img src="https://i.loli.net/2021/02/26/CU1EylLRTG69JAI.png" alt="image-20210226000712186"></p>
<h3 id="新的一年"><a href="#新的一年" class="headerlink" title="新的一年"></a>新的一年</h3><p>面对与COVID-19的影响，很难说工业界和FDA能否同步。FDA通常会在12月份披露今年有多少新药提交了申请，但随着《自然》杂志《药物发现》出版，FDA还没有披露名单。</p>
<p>一些值得注意的2021年潜在新药批准在2021年位于表5中，例如，百时美施贵宝公司生产的lisocabtagene maraleucel，可能成为第四种推向市场的CAR-T细胞疗法。其他三种FDA批准的CAR-T细胞疗法都是针对CD19表达细胞，而liso cabtagene Maraluecel则针对BCMA。2019年，百时美施贵宝以740亿美元收购Celgene，部分原因是为了获得Celgene/Juno Therapeutics的关于CAR-T细胞的专业知识。由于在COVID-19大流行期间检查生产设施的挑战，FDA推迟了对该申请的审核。</p>
<p>FDA预计将在2021年3月底前就Biogen的淀粉样β-靶向抗体aducanumab治疗阿尔茨海默病做出决定。Biogen最初报告称，aducanumab在其关键试验中失败，但2019年该公司在重新分析其临床数据后改变了策略。去年11月，一个独立的咨询小组投票反对批准这种抗体。当然，FDA没有义务遵循这一建议。</p>
<p>Amgen公司的KRAS-G12C抑制剂sotorasib正在接受关于非小细胞肺癌的研究，这是一条针对这一癌症靶点的深入研究路线。</p>
<p><img src="/Users/sujiaqi/Pictures/Typora/fPBkuWN9K6l7E4L.png" alt="image-20210226000736443"></p>
<h3 id="新药名单"><a href="#新药名单" class="headerlink" title="新药名单"></a>新药名单</h3><table>
<thead>
<tr>
<th><strong>Drug (brand name)</strong></th>
<th><strong>Sponsor</strong></th>
<th><strong>Properties</strong></th>
<th><strong>Indication</strong></th>
<th><strong>Review</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Avapritinib (Ayvakit)</td>
<td>Blueprint Medicines</td>
<td>PDGFRA, PDGFRA mutants and KIT kinase inhibitor</td>
<td>GIST with PDGFRA exon 18 mutations</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Teprotumumab (Tepezza)a</td>
<td>Horizon Therapeutics</td>
<td>IGF1R- directed mAb</td>
<td>Thyroid eye disease</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Tazemetostat (Tazverik)</td>
<td>Epizyme</td>
<td>EZH2 inhibitor</td>
<td>Epithelioid sarcoma</td>
<td>P, O, A</td>
</tr>
<tr>
<td>Lactitol (Pizensy)</td>
<td>Braintree Labs</td>
<td>Osmotic laxative</td>
<td>Chronic idiopathic constipation</td>
<td>S</td>
</tr>
<tr>
<td>Eptinezumab (Vyepti)a</td>
<td>Lundbeck</td>
<td>CGRP- directed mAb</td>
<td>Migraine</td>
<td>S</td>
</tr>
<tr>
<td>Bempedoic acid (Nexletol)</td>
<td>Esperion Therapeutics</td>
<td>ACL inhibitor</td>
<td>HeFH or atherosclerotic cardiovascular disease</td>
<td>S</td>
</tr>
<tr>
<td>Amisulpride (Barhemsys)</td>
<td>Acacia</td>
<td>Dopamine D receptor antagonist2</td>
<td>Nausea and vomiting after surgery</td>
<td>S</td>
</tr>
<tr>
<td>Rimegepant (Nurtec ODT)</td>
<td>Biohaven</td>
<td>CGRP receptor antagonist</td>
<td>Migraine</td>
<td>S</td>
</tr>
<tr>
<td>Isatuximab (Sarclisa)a</td>
<td>Sanofi</td>
<td>CD38- directed mAb</td>
<td>Multiple myeloma</td>
<td>S, O</td>
</tr>
<tr>
<td>Osilodrostat (Isturisa)</td>
<td>Recordati Rare Diseases</td>
<td>Cortisol synthesis inhibitor</td>
<td>Cushing disease</td>
<td>S, O</td>
</tr>
<tr>
<td>Ozanimod (Zeposia)</td>
<td>Celgene/Bristol Myers Squibb</td>
<td>S1P receptor modulator</td>
<td>Multiple sclerosis</td>
<td>S</td>
</tr>
<tr>
<td>Selumetinib (Koselugo)</td>
<td>AstraZeneca</td>
<td>MEK1/2 kinase inhibitor</td>
<td>Neurofibromatosis type 1</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Tucatinib (Tukysa)</td>
<td>Seagen</td>
<td>HER2 kinase inhibitor</td>
<td>HER2- positive breast cancer</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Pemigatinib (Pemazyre)</td>
<td>Incyte</td>
<td>FGFR1-3 kinase inhibitor</td>
<td>Cholangiocarcinoma</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Sacituzumab govitecan (Trodelvy)a</td>
<td>Immunomedics/Gilead</td>
<td>TROP2- directed ADC, with topoisomerase inhibitor</td>
<td>Triple- negative breast cancer</td>
<td>P, B, A</td>
</tr>
<tr>
<td>Opicapone (Ongentys)</td>
<td>Neurocrine</td>
<td>COMT inhibitor</td>
<td>Parkinson disease</td>
<td>S</td>
</tr>
<tr>
<td>Capmatinib (Tabrecta)</td>
<td>Novartis</td>
<td>MET kinase inhibitor</td>
<td>NSCLC</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Selpercatinib (Retevmo)</td>
<td>Eli Lilly/Loxo Oncology</td>
<td>RET kinase inhibitor</td>
<td>RET fusion-positive NSCLC and thyroid cancer</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Ripretinib (Qinlock)</td>
<td>Deciphera</td>
<td>KIT and PDGFRA kinase inhibitor</td>
<td>GIST</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Fluoroestradiol F-18</td>
<td>Zionexa</td>
<td>Radioactive diagnostic</td>
<td>Imaging, breast cancer</td>
<td>S</td>
</tr>
<tr>
<td>Artesunate (Artesunate)</td>
<td>Amivas</td>
<td>Artemisinin antimalarial</td>
<td>Severe malaria</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Flortaucipir F-18</td>
<td>Eli Lilly</td>
<td>Radioactive diagnostic</td>
<td>Imaging, tau in Alzheimer disease</td>
<td>P</td>
</tr>
<tr>
<td>Inebilizumab (Uplizna)a</td>
<td>Viela Bio</td>
<td>CD19- directed mAb</td>
<td>NMOSD</td>
<td>S, O, B</td>
</tr>
<tr>
<td>Lurbinectedin (Zepzelca)</td>
<td>Jazz</td>
<td>Alkylating drug</td>
<td>Small- cell lung cancer</td>
<td>P, O, A</td>
</tr>
<tr>
<td>Triheptanoin (Dojolvi)</td>
<td>Ultragenyx</td>
<td>Medium- chain triglyceride</td>
<td>LC- FAODs</td>
<td>S, O</td>
</tr>
<tr>
<td>Fostemsavir (Rukobia)</td>
<td>ViiV Healthcare</td>
<td>Attachment inhibitor</td>
<td>HIV</td>
<td>P, B</td>
</tr>
<tr>
<td>Remimazolam (Byfavo)</td>
<td>Acacia</td>
<td>Benzodiazepine</td>
<td>Procedural sedation</td>
<td>S</td>
</tr>
<tr>
<td>Cedazuridine; decitabine (Inqovi)</td>
<td>Otsuka</td>
<td>Cytidine deaminase inhibitor; nucleoside metabolic inhibitor</td>
<td>Myelodysplastic syndromes</td>
<td>P, O</td>
</tr>
<tr>
<td>Abametapir (Xeglyze)</td>
<td>Dr Reddy’s</td>
<td>Metalloproteinase inhibitor</td>
<td>Head lice</td>
<td>S</td>
</tr>
<tr>
<td>Tafasitamab (Monjuvi)a</td>
<td>MorphoSys</td>
<td>CD19- directed mAb</td>
<td>DLBCL</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Belantamab mafodotin (Blenrep)a</td>
<td>GlaxoSmithKline</td>
<td>BCMA- directed ADC, with microtubule inhibitor</td>
<td>Multiple myeloma</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Nifurtimox (Lampit)</td>
<td>Bayer</td>
<td>Nitrofuran antiprotozoal</td>
<td>Chagas disease</td>
<td>P, O, A</td>
</tr>
<tr>
<td>Oliceridine (Olinvyk)</td>
<td>Trevena</td>
<td>Opioid receptor agonist</td>
<td>Acute pain</td>
<td>S</td>
</tr>
<tr>
<td>Risdiplam (Evrysdi)</td>
<td>Roche/Genentech</td>
<td>SMN2 splicing modifier</td>
<td>Spinal muscular atrophy</td>
<td>P, O</td>
</tr>
<tr>
<td>Viltolarsen (Viltepso)</td>
<td>Nippon Shinyaku</td>
<td>Dystrophin splicing modifier</td>
<td>Duchenne muscular dystrophy</td>
<td>P, O, A</td>
</tr>
<tr>
<td>Satralizumab (Enspryng)a</td>
<td>Roche/Genentech</td>
<td>IL-6R- directed mAb</td>
<td>NMOSD</td>
<td>S, O, B</td>
</tr>
<tr>
<td>Clascoterone (Winlevi)</td>
<td>Cassiopea SpA</td>
<td>Androgen receptor inhibitor</td>
<td>Acne vulgaris</td>
<td>S</td>
</tr>
<tr>
<td>Somapacitan (Sogroya)a</td>
<td>Novo Nordisk</td>
<td>Growth hormone analogue</td>
<td>Growth hormone deficiency</td>
<td>S</td>
</tr>
<tr>
<td>Copper dotatate Cu-64</td>
<td>Radiomedix</td>
<td>Radioactive diagnostic</td>
<td>Imaging, cancer</td>
<td>P, O</td>
</tr>
<tr>
<td>Pralsetinib (Gavreto)</td>
<td>Blueprint Medicines/Roche</td>
<td>RET kinase inhibitor</td>
<td>RET fusion-positive NSCLC</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Atoltivimab; odesivimab; maftivimab (Inmazeb)a</td>
<td>Regeneron</td>
<td>Cocktail of Ebola glycoprotein- directed mAbs</td>
<td>Ebola virus</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Remdesivir (Veklury)</td>
<td>Gilead</td>
<td>Nucleotide analogue RNA polymerase inhibitor</td>
<td>COVID-19</td>
<td>P</td>
</tr>
<tr>
<td>Lonafarnib (Zokinvy)</td>
<td>Eiger</td>
<td>Farnesyltransferase inhibitor</td>
<td>HGPS</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Lumasiran (Oxlumo)</td>
<td>Alnylam</td>
<td>HAO1- directed siRNA</td>
<td>Hyperoxaluria type 1</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Naxitamab (Danyelza)a</td>
<td>Y- mAbs Therapeutics</td>
<td>GD2- directed mAb</td>
<td>High- risk neuroblastoma</td>
<td>P, O, B, A</td>
</tr>
<tr>
<td>Setmelanotide (Imcivree)</td>
<td>Rhythm</td>
<td>MC receptor agonist4</td>
<td>Rare genetic diseases of obesity</td>
<td>P, O, B</td>
</tr>
<tr>
<td>PSMA-11 Ga-68</td>
<td>UCLA</td>
<td>Radioactive diagnostic</td>
<td>Imaging, prostate cancer</td>
<td>S</td>
</tr>
<tr>
<td>Berotralstat (Orladeyo)</td>
<td>BioCryst</td>
<td>Plasma kallikrein inhibitor</td>
<td>Hereditary angioedema</td>
<td>S, O</td>
</tr>
<tr>
<td>Tirbanibulin (Klisyri)</td>
<td>Athenex</td>
<td>Microtubule inhibitor</td>
<td>Actinic keratosis</td>
<td>S</td>
</tr>
<tr>
<td>Margetuximab (Margenza)a</td>
<td>MacroGenics</td>
<td>HER2- directed mAb</td>
<td>HER2- positive breast cancer</td>
<td>S</td>
</tr>
<tr>
<td>Relugolix (Orgovyx)</td>
<td>Myovant Sciences</td>
<td>GnRH receptor antagonist</td>
<td>Prostate cancer</td>
<td>P</td>
</tr>
<tr>
<td>Ansuvimab (Ebanga)a</td>
<td>Ridgeback</td>
<td>Ebola glycoprotein-directed mAb</td>
<td>Ebola virus</td>
<td>P, O, B</td>
</tr>
<tr>
<td>Vibegron (Gemtesa)</td>
<td>Urovant Sciences</td>
<td>β- adrenoceptor agonist3</td>
<td>Overactive bladder</td>
<td>S</td>
</tr>
</tbody></table>
<h3 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h3><p>CDER：the FDA’s Center for Drug Evaluation and Research，FDA药物评价与研究中心</p>
<p>NMEs：Annual numbers of new molecular entities，新分子实体的年度数量</p>
<p>BLAs：biologics license applications ，生物制品许可证申请</p>
<p>CBER：the FDA’s Center for Drug Evaluation and Research，FDA药物评价和研究中心</p>
<p>Clinical benefit:临床益处，在特定疾病的情况下具有临床意义的积极治疗效果</p>
<p>Surrogate endpoints：在一些临床试验中，使用替代终点代替临床结果。当临床结果可能需要很长时间来研究时，或者在改善替代终点的临床益处（如控制血压）得到充分理解的情况下，使用替代终点。临床试验需要证明替代终点可以用来预测或关联临床益处。经过这种测试的替代终点被称为已验证的替代终点。2010年至2012年间，FDA批准了45%的基于替代终点的新药。</p>
<p>Orphan drugs:如果药物/生物制剂用于预防、治疗或诊断某些疾病（此类疾病的患者在美国人数小于200000），则可被认为孤儿药物。</p>
<p>Orphan designations: 审评用于特定疾病的特定药物，相关激励措施：税收抵免、免除患者费用、FDA批准特定孤儿药用于特定适应症后的7年市场独家经营权</p>
<p>Breakthrough designations: 突破性审定,一种旨在加速药物开发和审查的过程，与现有的治疗方法相比，该过程可能有实质性的改进。</p>
<p>Priority designations:优先审定,优先审查指定意味着FDA的目标是在6个月内对申请采取审查。</p>
<p>Accelerated designations:加速审定，在研究一种新药时，有时可能需要很多年才能了解一种药物是否真的对患者的生存有真正的影响。考虑到这一事实，它可能需要一个较长的时间来衡量一种药物的预期临床效益，在1992年FDA制定了加速审定条例。这些规定允许批准一些治疗严重疾病的药物（这些药物填补了替代终点即可）。</p>
<p>Fast Track:快速通道,快速通道是一个过程，旨在促进发展，并加快审查药物治疗严重疾病和填补空缺的医疗需求。</p>
<p>Standard review designation:标准审定,不符合优先审定标准的药物申请。</p>
<p><a href="https://www.qianzhan.com/analyst/detail/220/201113-3c76e626.html#:~:text=%E6%8A%97%E4%BD%93%E5%81%B6%E8%81%94%E8%8D%AF%E7%89%A9%20%28Antibody-Drug%20Conjugate%EF%BC%8CADC%29%E6%98%AF%E9%87%87%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%AD%90%E5%B0%86%E6%8A%97%E4%BD%93%E5%92%8C%E5%B0%8F%E5%88%86%E5%AD%90%E7%BB%86%E8%83%9E%E6%AF%92%E8%8D%AF%E7%89%A9%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%85%B6%E4%B8%BB%E8%A6%81%E7%BB%84%E6%88%90%E6%88%90%E5%88%86%E5%8C%85%E6%8B%AC%E6%8A%97%E4%BD%93%E3%80%81%E8%BF%9E%E6%8E%A5%E5%AD%90%E5%92%8C%E5%B0%8F%E5%88%86%E5%AD%90%E7%BB%86%E8%83%9E%E6%AF%92%E8%8D%AF%E7%89%A9,%28smallmolecular%20cytotoxic%20drug%EF%BC%8CSM%29%E3%80%82%20ADC%E5%88%A9%E7%94%A8%E6%8A%97%E4%BD%93%E4%B8%8E%E9%9D%B6%E6%8A%97%E5%8E%9F%E7%89%B9%E5%BC%82%E6%80%A7%E7%BB%93%E5%90%88%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%8C%E5%B0%86%E5%B0%8F%E5%88%86%E5%AD%90%E8%8D%AF%E7%89%A9%E9%9D%B6%E5%90%91%E9%80%92%E9%80%81%E8%87%B3%E8%82%BF%E7%98%A4%E7%BB%86%E8%83%9E%E8%BF%9B%E8%80%8C%E5%8F%91%E6%8C%A5%E6%9D%80%E4%BC%A4%E8%82%BF%E7%98%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82">ADC</a>：抗体偶联药物(Antibody-Drug Conjugate，ADC)是采用特定的连接子将抗体和小分子细胞毒药物连接起来，其主要组成成分包括抗体、连接子和小分子细胞毒药物(smallmolecular cytotoxic drug，SM)。ADC利用抗体与靶抗原特异性结合的特点，将小分子药物靶向递送至肿瘤细胞进而发挥杀伤肿瘤的作用。</p>
<p><a href="http://www.yixue.com/CAR-T">CAR-T</a>:全称是Chimeric AntigenReceptor T-Cell Immunotherapy，嵌合<a href="http://www.yixue.com/%E6%8A%97%E5%8E%9F">抗原</a>受体<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>免疫疗法。嵌合<a href="http://www.yixue.com/%E6%8A%97%E5%8E%9F">抗原</a>受体<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>（CAR-<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>）是将能识别某种<a href="http://www.yixue.com/%E8%82%BF%E7%98%A4">肿瘤</a><a href="http://www.yixue.com/%E6%8A%97%E5%8E%9F">抗原</a>的抗体的<a href="http://www.yixue.com/%E6%8A%97%E5%8E%9F">抗原</a>结合部与CD3-ζ链或FcεRIγ的胞内部分在体外偶联为一个嵌合蛋白，通过基因转导的方法转染患者的<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>，使其表达嵌合<a href="http://www.yixue.com/%E6%8A%97%E5%8E%9F">抗原</a>受体(CAR)。患者的<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>被“重编码”后，生成大量<a href="http://www.yixue.com/%E8%82%BF%E7%98%A4">肿瘤</a>特异性的CAR-<a href="http://www.yixue.com/T%E7%BB%86%E8%83%9E">T细胞</a>。这是一个出现了很多年，但是近几年才被改良使用到临床上的新型细胞疗法。和其它免疫疗法类似，它的基本原理就是利用病人自身的免疫细胞来清除癌细胞，但是不同的是，这是一种细胞疗法，而不是一种药。</p>
<p><a href="https://www.chemsrc.com/CatgBio/3639.html">CGRP receptor</a>:CGRP受体是异源三聚体：具有7个跨膜结构域的大肽，称为降钙素受体样受体（CLR或CRLR），由一种小的单个跨膜肽补充，称为受体活性修饰蛋白（RAMP1），形成CGRP特异性配体结合位点。 CGRP受体由神经，心血管和免疫系统中的多种不同细胞类型表达，这些细胞类型被认为在偏头痛病理学中起重要作用：在脑血管平滑肌上，它们引起血管舒张，在硬脑膜肥大细胞上引发它们的脱颗粒，在中央三叉神经的末端，其中CGRP是脊髓三叉神经尾核和脊髓背角的二阶伤害性神经元的神经调节剂，其中CGRP在诱导对触觉刺激的中枢敏化中具有类似的作用。 CGRP在外周和中枢神经元中产生。它是一种有效的肽血管扩张剂，可以在疼痛的传播中发挥作用。</p>
]]></content>
      <categories>
        <category>文献解读</category>
      </categories>
  </entry>
  <entry>
    <title>一篇综述一个领域｜谨慎对待对接</title>
    <url>/2021/02/16/paper/%E5%B0%8F%E5%BF%83%E5%AF%B9%E6%8E%A5/</url>
    <content><![CDATA[<h3 id="Cite"><a href="#Cite" class="headerlink" title="Cite"></a>Cite</h3><p>Chen YC. Beware of  docking! Trends Pharmacol Sci. 2015 Feb;36(2):78-95. doi:  10.1016/j.tips.2014.12.001. Epub 2014 Dec 24. Erratum in: Trends  Pharmacol Sci. 2015 Sep;36(9):617. PMID: 25543280.</p>
<h3 id="编前语"><a href="#编前语" class="headerlink" title="编前语"></a>编前语</h3><p>well，我知道你们此时充满疑惑，我刚刚不久之前刚刚写过一篇文章关于对接的综述，这次便是这个题目，就仿佛是在打自己的脸。但本质上某个领域有优势自然也有缺点，<strong>我们远未达到可以依靠某个单一技术手段去解决一个科学问题或者工程的时代</strong>。关于分子对接，上篇的综述主要是讲了其应用以及方法，这次，我们来看看这项技术手段的缺点，作为互补，以便更明确的展示DOCKING的全貌，以及他究竟能做些什么，应该注意什么。</p>
<p><img src="https://i.loli.net/2021/02/16/T7ylmM8tz9f1HZg.png" alt="image-20210216161043469"></p>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>分子对接经常被用于虚拟筛选或者先导化合物优化过程中。在过去十年中，分子对接相关的论文数量急剧增加。然而，在进行对接研究时，有许多问题需要考虑。经常出现的问题，如目标蛋白的错误结合位点、使用不合适的小分子数据库进行筛选、对接姿势的选择、较高的对接分数但在分子动力学（MD）模拟中失败，以及对复合物是抑制剂还是激动剂缺乏明确性。在执行对接之前，这些问题应该引起注意和并被考虑到。一些论文展示了丰富且全面的生化实验，但最终结果只是一个简单的对接图。此综述提供了一些证据表明，有可能对接得分很高，但对接结果是存在问题的。在某些情况下，对接精度甚至可以从0%变为92.66%。因此，请认真对待。</p>
<p><img src="https://i.loli.net/2021/02/16/dH8LyeCDZsiPUJR.png" alt="image-20210216163805226"></p>
<h3 id="对接本质是基于结构的药物筛选（SBDD）"><a href="#对接本质是基于结构的药物筛选（SBDD）" class="headerlink" title="对接本质是基于结构的药物筛选（SBDD）"></a>对接本质是基于结构的药物筛选（SBDD）</h3><blockquote>
<p>请注意是基于结构的对接，并不是基于对接的结构</p>
</blockquote>
<p>从20世纪60年代开始，随着物理学、化学、信息技术、生物化学和计算机的发展，分子对接已经成为一种强有力的工具和基本技术，不仅在药物筛选方面，而且在蛋白质-蛋白质相互作用和纳米材料等方面都显示出了巨大的潜力。目前计算机辅助药物设计（CADD）领域主要是将小分子对接到大分子（特别是蛋白质靶点上），其应用案例逐年增加。在现代CADD中，基于结构的药物设计是必不可少的，大多数大型制药公司都有这个部门。许多商业药物是直接使用CADD方法进行设计的。毫无疑问，在理解药物作用的分子机制上，对接技术是一项非常重要的科学进步，特别是当三位顶尖计算科学家获得2013年诺贝尔化学奖时。</p>
<p>蛋白质-配体或蛋白质-蛋白质对接是一种计算技术，用于预测配体与蛋白质受体结合时的取向。多数情况下，可以选择最佳的“结合亲和力”配体进行进一步的生物化学实验。因为对接很简单，设备要求也很低（甚至在个人电脑上也能工作），对接相关的论文在过去十年里急剧增加。然而，我们能否相信这些对接研究的结果？本文对相关领域进行了调查，指出了优势和劣势。评估表明，精确性是对接研究的一个主要问题，因为如果不能精确地对接，那么这些论文就没有什么价值。</p>
<p>即使在知名期刊上，也能找到可疑的对接结果。常见的问题有：<strong>靶蛋白的结合位点不准确</strong>，<strong>使用不合适的小分子数据库进行筛选</strong>，<strong>对接姿势（POSE）的选择</strong>，<strong>高对接分数（结合亲和力）但在MD模拟中失败</strong>，<strong>缺乏对化合物是抑制剂还是激动剂的解释</strong>，或者<strong>对接结果与结果不一致生物测定</strong>。一些情况常常出现在一些顶级期刊上，这些期刊显示了极好的生物测定，但只有一个简单的对接图。对接结果在解释这些问题时应该引起警惕和关注。虽然有些论文通过比较对接前后配体的结合姿势差异来表明对接结果的准确性很高，但作者提出了一些观点，表明对接仍然可能存在问题。在某些情况下，对接精度甚至可以从0%变为92.66%。</p>
<h3 id="对接算法和程序"><a href="#对接算法和程序" class="headerlink" title="对接算法和程序"></a>对接算法和程序</h3><blockquote>
<p>Well，基本关于对接的论文都绕不开此项的讨论，我上一篇可能更详细，但是此篇主要偏向于对接程序的总结，总而言之，互有偏重。</p>
</blockquote>
<p>对接的最初概念来自于“锁钥”概念，但将“钥匙”（配体）与“锁”（受体蛋白）匹配的算法多种多样。下表列出了对接程序、对接web服务器、屏幕软件和屏幕web服务器的最新发展，从中我们可以看出，近年来新算法的数量不断增加。如果我们进一步分析所有对接软件，我们可以看到最常用的对接程序是Autodock和GOLD。这并不意味着Autodock或GOLD比其他对接程序更精确，它们只是更受欢迎和知名。它们的高引用率可能是因为这些程序是免费的，并且比最近的其他对接程序创建得更早。目前，有一种新的蛋白质结构预测算法Rosetta(<a href="http://boinc.bakerlab.org/)%EF%BC%8C%E4%B9%9F%E5%BE%97%E5%88%B0%E4%BA%86%E9%AB%98%E5%BA%A6%E8%AF%84%E4%BB%B7%E3%80%82">http://boinc.bakerlab.org/)，也得到了高度评价。</a></p>
<img src="https://i.loli.net/2021/02/16/F5PC6aLHSUJQoT1.png" alt="image-20210216165225143" style="zoom:50%;" />

<p>尽管程序多种多样，但每个对接程序的算法必须在速度和精度之间取得平衡。对接的算法也因评分函数的不同而有差异。结合亲和力（Binding affinity）通常被认为是一个最优先考虑因素。有不同的对接程序可以供用户根据自己的特殊要求进行选择。目前，对接算法包含了了基于结构的药物设计（SBDD）的不同方面，如<strong>基于片段的药物设计</strong>、<strong>柔性对接</strong>、<strong>水，特定pH值溶剂下对接</strong>。例如，如果我们需要从一个数据库中筛选超过10000种化合物，那么<strong>柔性对接</strong>可能不是一个好的选择，除非我们有一台强大的服务器。如果我们只需要在特定的蛋白质结合位点、特定的pH值、水或溶剂化条件下对接一些化合物，那么柔性对接程序可能是一个不错的选择。因此，对接程序的选择取决于您拥有的<strong>硬件类型</strong>以及正在筛选的<strong>数据库</strong>的规模。根据本文作者经验，将药物从CADD转化为临床是比较困难的。例如，通过对接从中医药数据库中筛选出的一些top hits在最终生物活性测试中失败。</p>
<h3 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h3><p>最新的软件和网络服务器，基本都总结自此网站：<a href="http://www.click2drug.org/">http://www.Click2Drug.org</a> </p>
<blockquote>
<p>这个网址还是不错的，有时间单独出一篇</p>
</blockquote>
<p>瑞士生物信息学研究所（SIB-swissinstituteofbioinformatics）提供了一系列计算机辅助药物设计软件和基于结构和配体计算的web服务</p>
<blockquote>
<p>table 我就不翻译了，大家自己去需要的部分进行探索就好</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/16/VbtZ9kzcsvOQgxf.png" alt="image-20210216170735486"></p>
<p><img src="https://i.loli.net/2021/02/16/CmfxMplHetAuNvF.png" alt="image-20210216171618180"></p>
<p><img src="https://i.loli.net/2021/02/16/W3tpC7vh19gMlUS.png" alt="image-20210216171648825"></p>
<p><img src="https://i.loli.net/2021/02/16/yfx2URqk3PenozM.png" alt="image-20210216171719373"></p>
<p><img src="https://i.loli.net/2021/02/16/AP1soSZpj6JhzbE.png" alt="image-20210216171741160"></p>
<p><img src="https://i.loli.net/2021/02/16/2FyuqUEIRDghSfv.png" alt="image-20210216171806074"></p>
<p><img src="https://i.loli.net/2021/02/16/L9iwhjV6xCe8D15.png" alt="image-20210216171829322"></p>
<p>然而，如果hits首先来自生物测定，例如，如果是通过自动化机器人技术、数据处理和体外软件利用高通量筛选（HTS）中筛选出来的——那么就更容易转移到体内。也更容易解释潜在的生物学机制。在对接研究中，谨慎是很重要的。下面列举了一些重要的因素，开发人员在进行对接时应该牢记这些影响因素。</p>
<blockquote>
<p>只是列举，不是全部</p>
</blockquote>
<h3 id="蛋白结构可用吗？可信吗？"><a href="#蛋白结构可用吗？可信吗？" class="headerlink" title="蛋白结构可用吗？可信吗？"></a>蛋白结构可用吗？可信吗？</h3><p>在尝试对接之前，需要做大量的准备工作。这包括使用配体和蛋白质的能量最小化来确定稳定的三维结构。</p>
<blockquote>
<p>当然此项属于部分重要操作，但不是必须操作，毕竟局部最小值不等于全局最小值。</p>
</blockquote>
<p>这项准备工作可以在下面的流程图中看到。如图所示，目标蛋白质序列应该可知，然后蛋白质结构应该可用，可以从同源性建模、从头建模或从蛋白质数据库（PDB）下载(<a href="http://www.rcsb.org/pdb)%E4%B8%8B%E8%BD%BD%E8%9B%8B%E7%99%BD%E7%BB%93%E6%9E%84">http://www.rcsb.org/pdb)下载蛋白结构</a>. 如果蛋白质和配体准备好了，就可以进行对接。现阶段的一个主要问题是蛋白质结构是否可用，是否可靠。如果蛋白质结构是从PDB数据库中下载，必须注意分辨率和获得蛋白质结构的条件。<strong>不同的温度，可以获得不同的蛋白结构。</strong> 我们可以直接利用这些蛋白质结构而不需要进一步的能量最小化或MD和聚类吗？MD模拟得到的蛋白质结构的精度会受到力场精度的影响。如果在PDB中没有蛋白质结构，那么难度将急剧上升。蛋白质结构预测的方法很多。此外，许多不同类型的验证方法被用来提高结构预测的准确性，例如著名的Ramachandran plot（拉氏图）。</p>
<img src="https://i.loli.net/2021/02/16/Isk2FitvxOVfZm1.png" alt="image-20210216171418581" style="zoom:33%;" />

<h3 id="柔性对接还是刚性对接"><a href="#柔性对接还是刚性对接" class="headerlink" title="柔性对接还是刚性对接"></a>柔性对接还是刚性对接</h3><p>刚性对接是指蛋白质和配体构象固定，使键角或长度不变。柔性对接，允许构象的变化，今天被广泛使用的是半柔性对接，尽管它需要更多的时间和计算资源。其他对接方法包括<strong>改变溶剂化、改变pH值以及在有无水的情况下对接</strong>。用户可以根据其计算硬件和目标蛋白质的特性选择不同的对接模式。对接大致可以分为四种模式（从原理上来说）：锁和钥匙、构象异构、诱导契合和构象选择。从下图可以看出，似乎只有诱导契合模式会改变口袋的形状。然而，根据MD实验的模拟，配体进入结合口袋有时会改变结合位点的形状。当配体结合时发生构象变化时，刚性对接程序将不能提供有用的结果。这表明，将蛋白质结构构象固定的对接结果可能存在错误。</p>
<img src="https://i.loli.net/2021/02/17/9a2RstFZqhYCWTv.png" alt="image-20210217114604012" style="zoom:33%;" />

<h3 id="如何去选择最佳的打分函数"><a href="#如何去选择最佳的打分函数" class="headerlink" title="如何去选择最佳的打分函数"></a>如何去选择最佳的打分函数</h3><p>有许多评分函数，例如，LigScore1、LigScore2、PLP1、PLP2、PMF、Dock Score、Jain、Ludi和结合能。如何选择合适的打分函数来挑选出正确的结合姿势和可能的hits？这是一个很难回答的问题。理论上，较低的吉布斯自由能表明蛋白质-配体复合物更稳定。然而，这些打分函数是针对用户的不同需求而设计的。很难确定哪种评分函数适合不同的靶蛋白。例如，我们之前已经讨论了每个打分函数的准确性，这是使用IC50与每个评分函数的回归得出的结果。我们还提出了加权打分函数，并表明其精度优于一致性打分。加权打分比一致性打分函数更准确也就不足为奇了。一致性评分允许用户选取多个或所有评分函数来评估。每个评分函数在共识评分函数中的权重相等。与此相反，加权评分是基于它们的回归系数。在该算法中，回归系数越高，权重越大。因此，加权评分比普通的一致性打分更准确。<br>然而，加权评分函数必须有足够的关于化合物IC50的信息，以便从评分函数中获得预测IC50的公式。它比一致性得分更精确，但不太实用，因为在大多数筛选情况下，很难获得足够的IC50数据。如果一个靶蛋白有数百个不同的配体具有不同的IC50，那么我建议使用加权评分。然而，根据我们的经验，很难从一篇论文中收集到如此多的生物活性数据。如果从不同的论文中收集生物活性数据，它们可能会因实验室环境以及protocol的不同而有所不同。普通的一致性评分避免了这个问题，因为它不需要生物活性数据。选择一致性打分或加权得分涉及到用户的所处的环境。显然，很难获得如此庞大的生物活性数据，然后用它得到最优权重评分函数，这需要大量的工作。</p>
<blockquote>
<p>加权打分函数</p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2021/02/17/PB5VqANcLarSfxD.png" alt="image-20210217115304330"></p>
</blockquote>
<blockquote>
<p>其中打分函数的数目；pIC50=-log（IC50）；SFc是对照打分函数的值；SFi是打分函数的值；Wi是权重。方程中的SFc用于归一化加权方程。</p>
</blockquote>
<h3 id="打分函数的精确度"><a href="#打分函数的精确度" class="headerlink" title="打分函数的精确度"></a>打分函数的精确度</h3><p>决定使用什么样的对接程序来对特定的靶蛋白进行筛选存在问题的。基本上，如果可以对生物活性与评分函数进行回归分析，那么我们就可以选择最佳的打分函数回归作为标准。准确度似乎是可以接受的，但是既然大多数hits在计算、体外或体内似乎都有很好的结合亲和力，为什么很难找到一种商业药物的先导化合物呢？<strong>首先，如果我们仅仅从PDB网站下载蛋白质-配体复合物，并从复合物中删除配体而不进一步分离纯蛋白质结构，那么蛋白质结构可能会有问题。其次，结合位点的环境是一个大问题。例如，结合位点可能位于细胞膜的内表面，因此即使配体具有较高的dock分数，它仍然必须转移到疏水性脂双层中才能到达结合域。第三，目标蛋白可能位于人体内不同的pH值。</strong></p>
<h3 id="如何知道具有较高打分的候选化合物是否可以说吗此药物时拮抗剂还是抑制剂？"><a href="#如何知道具有较高打分的候选化合物是否可以说吗此药物时拮抗剂还是抑制剂？" class="headerlink" title="如何知道具有较高打分的候选化合物是否可以说吗此药物时拮抗剂还是抑制剂？"></a>如何知道具有较高打分的候选化合物是否可以说吗此药物时拮抗剂还是抑制剂？</h3><p>如何确定一个高分化合物是一个抑制剂还是激动剂是十分困难的。许多研究仅仅使用一个对接程序，然后声称他们已经找到了激动剂或抑制剂。但是我们怎么知道这个复合体的真正机制呢？对接程序只提供计算出的结合亲和力。仅此而已，没有别的。一些论文声称，一个对接结果良好的配体表明它是一个强有力的激动剂或抑制剂。当然，在我们对生物测定进行进一步验证之前，我们不会知道它是激动剂还是抑制剂。从对接结果我们唯一确定的是配体在结合位点结合良好。因此，除非进行了其他验证，否则不建议在论文中过度解释对接结果。</p>
<h3 id="对接结果与基于配体的研究不一致"><a href="#对接结果与基于配体的研究不一致" class="headerlink" title="对接结果与基于配体的研究不一致"></a>对接结果与基于配体的研究不一致</h3><p>有时，基于配体的研究表明，该模型是完美的，具有良好的R方（表明该模型是可靠的预测）。然后，我们可以使用这个基于配体的模型（LBDD）来预测潜在强效candidates。不幸的是，根据我们的大多数研究，大多数基于结构的结果似乎与基于配体的结果不一致。McGaughey认为，这种差异可能是因为所有的虚拟筛选方法都依赖于数据库，对于特定的靶点可能会有很大的不同。例如，在表2中，control化合物（T2384）具有非常高的对接分数，因此基于不同算法的LBDD模型也有非常高的预测活性，包括多元线性回归（MLR）、支持向量机（SVM）和贝叶斯（BNT）。然而，其他化合物也有很高的预测活性，但dock分数很低。由表2可知，对接结果显示结合能最低的对照化合物（D71904）同样在基于配体的预测（MLR和SVM）上表现出的活性也很低。相比之下，其他化合物在dock上表现较差，但在基于配体的预测（MLR和SVM）上活性很高。在表3中，较差的dock得分也显示了MLR、SVM和BNT的高预测活性。然而，具有讽刺意味的是，control化合物（SAHA）具有非常高的dock分数，但是MLR和BNT的预测结果非常差。</p>
<img src="https://i.loli.net/2021/02/17/IDvH6yeZkMSLi9R.png" alt="image-20210217122114904" style="zoom:50%;" />

<img src="https://i.loli.net/2021/02/17/l7GRQHSnaKF1LPJ.png" alt="image-20210217122150356" style="zoom:50%;" />

<img src="https://i.loli.net/2021/02/17/BUN3JZLHTmKDtrO.png" alt="image-20210217122217407" style="zoom:50%;" />

<p>从表4可以看出，基于配体的研究（MLR、SVM和BNT）的预测活性非常高，因此表明这些化合物应该是有效的。然而，他们也表现出很差的dock分数。表5也显示了预测活性很高，但dock得分很低（方框2）。上述问题在CADD过程中并不少见，但很少出现在已发表的论文中。在他们的论文，作者把最好的数据与高dock分数结合在了一起。然而，最好的hits可能无法从最高的dock得分中找到。从我们过去的研究中，从这样的筛选中获得的前10个最有效的配体通常在真正的生物测试中失败。然而，前100名的配体往往在体外实验中显示出了good hits。这表明，虽然最高的对接分数可能不会提供最好的线索，但总的来说，对接的预测似乎没有那么糟糕。可以肯定的是，对接是基于理论计算算法，并肯定优于随机生化实验测试。</p>
<img src="https://i.loli.net/2021/02/17/9h7bdIWDQzMs5Xo.png" alt="image-20210217122355813" style="zoom:50%;" />

<h3 id="对接结果与MD结果不一致"><a href="#对接结果与MD结果不一致" class="headerlink" title="对接结果与MD结果不一致"></a>对接结果与MD结果不一致</h3><p>从PubMed或Web of Science数据库检索到的对接论文大多缺乏MD模拟的进一步验证。对接是一种可以计算蛋白质-蛋白质或蛋白质-配体复合物结合亲和力的工具。分析一个300 kDa的蛋白质和50-300 Da的配体结合结构通常只需要1-10秒。换句话说，对接是高通量筛选配体数据库的理想工具。MD模拟也是计算复合物构象变化“运动”的一种技术。对接和MD最大的不同时时间。对接只考虑结合能或亲和力。相比之下，MD强调了结合构象随时间的变化，与对接实验相比，MD增加了每次筛选的时间。在图5中，配体（当归）与蛋白磷酸酶2A（PP2A）的结合位点对接良好，对接得分最高。然而，对接所获得的姿势与经过20 ns的MD模拟后的最终姿势之间存在巨大差异。同样的问题可以在图6-8中看到。MD模拟也说明了配体可能“飞”出结合口袋的过程，表明MD模拟可能是我们从对接结果得出任何结论之前的必要验证。通常MD的模拟时间不是很长（由于硬件的限制，通常小于1ms）。因此，MD在CADD中肯定不是<strong>决定性的或必要的</strong>，但可以提供对接结果的进一步验证。</p>
<img src="https://i.loli.net/2021/02/17/Djwrlt1dQYsb9xX.png" alt="image-20210217123530505" style="zoom:50%;" />

<img src="https://i.loli.net/2021/02/17/5z7XEMVvGpI6RQD.png" alt="image-20210217123619732" style="zoom:50%;" />

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p><img src="/Users/sujiaqi/Pictures/Typora/image-20210217123753747.png" alt="image-20210217123753747"></p>
<p>现在越来越多的研究依赖于先进的计算工具，因此对接结果问题变得越来越重要。许多专业的生物化学家在top期刊上发表了重要的研究结果，但只有一个简单的数字来验证配体与受体结合的关键残基。毫无疑问，这些论文都是非常重要的；然而，他们都缺乏MD研究的验证。并不是说这些类型的研究必须总是伴随着MD模拟的验证。然而，经验表明，单靠对接分析可能得出不准确的配体结合构象。<strong>尽管dock分数很高，有时配体会在MD模拟过程中飞走。</strong>因此，我强烈建议科学家们应该谨慎得出他们的结论，特别是如果只有一个对接或虚拟筛选结果，而没有进一步的验证。上图和下面提出了一个框架来对传统CADD进行改进。</p>
<blockquote>
<p>计算机辅助药物设计（CADD）的集成框架与改进方法</p>
<p>CADD方案的完整流程图包括基于结构的药物设计（SBDD）、基于配体的药物设计（LBDD）、先导化合物优化，最后通过分子动力学（MD）模拟进行验证。对于SBDD，蛋白质结构可从蛋白质数据库获得(<a href="http://www.rcsb.org/pdb/home)%E6%88%96%E8%80%85%E7%94%A8%E5%90%8C%E6%BA%90%E5%BB%BA%E6%A8%A1%E6%88%96%E4%BB%8E%E5%A4%B4%E5%BB%BA%E6%A8%A1%E3%80%82%E9%A2%84%E6%B5%8B%E8%8E%B7%E5%BE%97%E7%9A%84%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%BB%93%E6%9E%84%E5%BA%94%E9%80%9A%E8%BF%87**profiles-3D%E3%80%81Ramachandran%E5%9B%BE%E5%92%8C%E6%97%A0%E5%BA%8F%E8%9B%8B%E7%99%BD%E8%B4%A8%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6**%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81%E3%80%82%E5%A6%82%E6%9E%9C%E8%9B%8B%E7%99%BD%E8%B4%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%93%E5%90%88%E4%BD%8D%E7%82%B9%E7%AC%A6%E5%90%88%E5%BF%85%E8%A6%81%E7%9A%84%E6%A0%87%E5%87%86%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E5%AF%B9%E6%8E%A5%E3%80%82%E5%AF%B9%E4%BA%8E%E7%AD%9B%E9%80%89%EF%BC%8C%E5%BA%94%E6%8F%90%E4%BE%9B%E5%90%88%E9%80%82%E7%9A%84%E5%B0%8F%E5%88%86%E5%AD%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82%E7%A0%94%E7%A9%B6%E4%BA%BA%E5%91%98%E8%BF%98%E5%8F%AF%E4%BB%A5%E7%AD%9B%E9%80%89%E8%82%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%82">http://www.rcsb.org/pdb/home)或者用同源建模或从头建模。预测获得的蛋白质结构应通过**profiles-3D、Ramachandran图和无序蛋白质分析软件**进行验证。如果蛋白质的结构和结合位点符合必要的标准，我们就可以进行对接。对于筛选，应提供合适的小分子数据库。研究人员还可以筛选肽数据库。</a><br>SBDD通常与LBDD相结合来筛选潜在活性化合物。LBDD的方法是建立基于生物活性或分子描述符的模型，然后预测SBDD筛选出的化合物的生物活性。最著名的基于配体的模型<strong>QSAR</strong>是基于生物活性和药效团特征的。尽管这些模型有很大的不同，但它们都有相同的目标：在没有目标蛋白结构的情况下预测生物活性。<br>最后，利用MD模拟进一步验证了蛋白质结合位点的最佳对接复合物。</p>
</blockquote>
<p>总之，药物设计原则可分为四种模式，（A）快速结合和长滞留时间（1/Koff），（B）缓慢结合但停留时间长，（C）快速结合但停留时间短，以及（D）缓慢结合和停留时间短。由于硬件和软件的限制，目前不可能使用MD来模拟复合物结构4小时或8小时知乎德变化。在未来，硬件或软件的进展可能允许MD模拟更长时间。但是，目前，MD模拟时间很短（只有几毫秒或微秒）。在本文中，MD模拟的飞走配体只是证明dock得分最高的配体并不意味着该配体是有效的先导化合物的一个证据。这是许多已发表论文中经常出现的错误。理论上，（A）模式可能是药物设计的最佳选择。然而，在实验中，我们发现超过300种商业药物和对照化合物位于（B）和（C）情境下中。辩论仍在继续。。。</p>
<blockquote>
<p>Well,基本就可以分为，快结合慢解离，慢结合慢解离，快结合快解离，慢结合快解离</p>
</blockquote>
<p><img src="https://i.loli.net/2021/02/17/kD3RHgrh9IWPaVp.png" alt="image-20210217124434139"></p>
]]></content>
      <categories>
        <category>文献解读</category>
      </categories>
  </entry>
  <entry>
    <title>OpenMM.No.2.可视化界面及力场</title>
    <url>/2021/02/02/openmm/oenmm-2/</url>
    <content><![CDATA[<p>创建openmm脚本的一种方法是从上面给出的示例开始，并对其进行自定义以满足实际需求，但是还有一个更简单的选择。</p>
<p> OpenMM-Setup是一个图形应用程序，可引导完成加载输入文件和设置选项的整个过程。 然后，它会生成一个完整的脚本，甚至可以直接运行。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gn90llb3bkj30vq0jpn11.jpg"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge openmm-setup</span><br><span class="line">#启动</span><br><span class="line">openmm-setup</span><br></pre></td></tr></table></figure>

<p>它将自动在Web浏览器中打开一个显示用户界面的窗口。</p>
<p>OpenMM-Setup不仅仅是脚本生成器。 它可以解决输入文件中的问题，添加缺失的原子，构建膜和water box等。 这是快速完成所有必要准备和设置的非常简单的方法。 </p>
<p>openmm强烈建议所有新手到专家使用OpenMM-setup。</p>
<p>我这里使用的是<strong>chrome</strong></p>
<p>比较容易使用，会单独出一章</p>
<img src="/Users/sujiaqi/Desktop/d5896691e28d602f21209709df02e47c9e8e68ac.png" title="" alt="" width="650">

<h2 id="模拟参数"><a href="#模拟参数" class="headerlink" title="模拟参数"></a>模拟参数</h2><h3 id="platforms"><a href="#platforms" class="headerlink" title="platforms"></a>platforms</h3><p>创建模拟时，可以选择要使用的平台。</p>
<p> OpenMM包括四个平台：Reference，CPU，CUDA和OpenCL。 </p>
<p> 可以通过三种方式选择平台：</p>
<p>1.默认情况下，OpenMM将尝试选择最快的可用平台。 通常，它的选择是比较合理的，但是有时需要自定义。</p>
<p>2.或者，可以将OPENMM_DEFAULT_PLATFORM环境变量设置为要使用的平台的名称。 这将覆盖默认选项。</p>
<p>3.最后，在创建模拟时，可以在脚本中显式指定Platform对象。</p>
<p> 以下各行指定使用CUDA平台：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#platform参数应为下列：</span></span><br><span class="line">platform = Platform.getPlatformByName(<span class="string">&#x27;CPU&#x27;</span>)</span><br><span class="line">simulation = Simulation(prmtop.topology, system, integrator, platform)</span><br></pre></td></tr></table></figure>

<p>您还可以自定义特定平台的属性，以进行计算。 </p>
<p>有关每个平台支持的属性的详细信息，请参见Chapter <a href="http://docs.openmm.org/latest/userguide/library.html#platform-specific-properties">10</a></p>
<p> 例如，以下代码指定使用两个GPU（CUDA：0和1）之间进行并行处理工作，以双精度执行所有计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">platform = Platform.getPlatformByName(<span class="string">&#x27;CUDA&#x27;</span>)</span><br><span class="line">properties = &#123;<span class="string">&#x27;DeviceIndex&#x27;</span>: <span class="string">&#x27;0,1&#x27;</span>, <span class="string">&#x27;Precision&#x27;</span>: <span class="string">&#x27;double&#x27;</span>&#125;</span><br><span class="line">simulation = Simulation(prmtop.topology, system, integrator, platform, properties)</span><br></pre></td></tr></table></figure>

<h3 id="力场"><a href="#力场" class="headerlink" title="力场"></a>力场</h3><p>创建力场时，可以指定一个或多个XML文件，使用加载力场定义。 </p>
<p>通常，会有一个文件定义主要力场，可能还有另一个文件定义水模型（隐式或显式）。</p>
<p> 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">forcefield = ForceField(<span class="string">&#x27;amber14-all.xml&#x27;</span>, <span class="string">&#x27;amber14/tip3pfb.xml&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在某些情况下，一个XML文件包含其余的力场文件。</p>
<p> 例如，amber14-all.xml实际上只是加载几个不同文件的快捷方式，这些文件共同构成了AMBER14力场。 </p>
<p>如果需要对加载哪些参数进行更精细的控制，则可以单独指定组件文件。</p>
<p>请注意，某些力场和水模型包括“额外粒子”，例如 lone pairs or Drude particles。</p>
<p> 示例包括CHARMM极化力场以及所有4或5点水模型。 要使用这些力场，必须首先将多余的粒子添加到 <strong>拓扑</strong> 中。 </p>
<p>下面描述的力场是与OpenMM捆绑在一起的力场。 </p>
<p>其他力场可从<strong><a href="https://github.com/choderalab/openmm-forcefields">https://github.com/choderalab/openmm-forcefields</a></strong> 在线获得。</p>
<h5 id="Amber14"><a href="#Amber14" class="headerlink" title="Amber14"></a>Amber14</h5><p>Amber14 力场由各种文件组成，这些文件定义了蛋白质，DNA，RNA，脂质，水和离子的参数。</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Parameters</th>
</tr>
</thead>
<tbody><tr>
<td><code>amber14/protein.ff14SB.xml</code></td>
<td>Protein (recommended)</td>
</tr>
<tr>
<td><code>amber14/protein.ff15ipq.xml</code></td>
<td>Protein (alternative)</td>
</tr>
<tr>
<td><code>amber14/DNA.OL15.xml</code></td>
<td>DNA (recommended)</td>
</tr>
<tr>
<td><code>amber14/DNA.bsc1.xml</code></td>
<td>DNA (alternative)</td>
</tr>
<tr>
<td><code>amber14/RNA.OL3.xml</code></td>
<td>RNA</td>
</tr>
<tr>
<td><code>amber14/lipid17.xml</code></td>
<td>Lipid</td>
</tr>
<tr>
<td><code>amber14/tip3p.xml</code></td>
<td>TIP3P water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#jorgensen1983">[2]</a> and ions</td>
</tr>
<tr>
<td><code>amber14/tip3pfb.xml</code></td>
<td>TIP3P-FB water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#wang2014">[3]</a> and ions</td>
</tr>
<tr>
<td><code>amber14/tip4pew.xml</code></td>
<td>TIP4P-Ew water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#horn2004">[4]</a> and ions</td>
</tr>
<tr>
<td><code>amber14/tip4pfb.xml</code></td>
<td>TIP4P-FB water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#wang2014">[3]</a> and ions</td>
</tr>
<tr>
<td><code>amber14/spce.xml</code></td>
<td>SPC/E water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#berendsen1987">[5]</a> and ions</td>
</tr>
</tbody></table>
<p>为了方便，可以将文件amber14-all.xml用作包含：<code>amber14 / protein.ff14SB.xml，amber14 / DNA.OL15.xml，amber14 / RNA.OL3.xml和amber14 / lipid17.xml</code>的快捷方式。 </p>
<p>在大多数情况下，在构建模型时，您只需包含amber14-all.xml，再加上其中一种水模型，例如<code>amber14 / tip3pfb.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forcefield &#x3D; ForceField(&#39;amber14-all.xml&#39;, &#39;amber14&#x2F;tip3pfb.xml&#39;)</span><br></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="CHARMM36"><a href="#CHARMM36" class="headerlink" title="CHARMM36"></a>CHARMM36</h4><p>CHARMM36 力场提供了蛋白质，DNA，RNA，脂质，碳水化合物，水，离子和各种小分子的参数（有关完整参考资料，请参见此处）。</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Parameters</th>
</tr>
</thead>
<tbody><tr>
<td><code>charmm36.xml</code></td>
<td>Protein, DNA, RNA, lipids, carbohydrates, and small molecules</td>
</tr>
<tr>
<td><code>charmm36/water.xml</code></td>
<td>Default CHARMM water model (a modified version of TIP3P<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#jorgensen1983">[2]</a>) and ions</td>
</tr>
<tr>
<td><code>charmm36/spce.xml</code></td>
<td>SPC/E water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#berendsen1987">[5]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip3p-pme-b.xml</code></td>
<td>TIP3P-PME-B water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#price2004">[7]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip3p-pme-f.xml</code></td>
<td>TIP3P-PME-F water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#price2004">[7]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip4pew.xml</code></td>
<td>TIP4P-Ew water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#horn2004">[4]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip4p2005.xml</code></td>
<td>TIP4P-2005 water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#abascal2005">[8]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip5p.xml</code></td>
<td>TIP5P water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#mahoney2000">[9]</a> and ions</td>
</tr>
<tr>
<td><code>charmm36/tip5pew.xml</code></td>
<td>TIP5P-Ew water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#rick2004">[10]</a> and ions</td>
</tr>
</tbody></table>
<p>charmm36.xml将除水和离子力场以外的所有xml都捆绑到一个文件中。</p>
<p> 在大多数情况下，只需包含该文件，再加上一个水模型，例:<code>charmm36 / water.xml</code>，它指定了默认的CHARMM水模型（TIP3P 的修改版）和离子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forcefield &#x3D; ForceField(&#39;charmm36.xml&#39;, &#39;charmm36&#x2F;water.xml&#39;)</span><br></pre></td></tr></table></figure>

<h5 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h5><ul>
<li><p>charmm36 /目录中包含的溶剂模型XML文件同时包含水和离子模型，因此，如果错误地指定了tip3p.xml而不是charmm36/water.xml，则可能会引发异常： 系统中缺少离子参数。</p>
</li>
<li><p>CHARMM广泛使用<strong>patches</strong>，这些patches会与残基模板自动结合，通过ForceField创建扩展的patches残基模板库。 这意味着修补残基（例如ACE和NME修补末端）必须作为单个残基出现，以便ForceField正确匹配残基模板并应用参数。 由于这些修补的残基不是标准的PDB残基，因此Modeller不知道如何向这些非标准残基中添加氢，并且<strong>输入拓扑必须已经包含适当的氢</strong>。</p>
</li>
<li><p>如果读取从CHARMM-GUI之类程序处理之后的PDB文件可能会出现问题。某些程序会生成不符合<strong>PDB标准的PDB文件</strong>，并忽略指定残基（例如半胱氨酸）之间键的CONECT记录，可能导致二硫键的检测和参数分配出现问题。 <strong>确保您阅读的文件符合有关键和非标准残基定义的适当标准。</strong>  如果使用的是CHARMM-GUI中的文件，则直接加载PSF文件最简单。</p>
</li>
</ul>
<h4 id="AMOEBA"><a href="#AMOEBA" class="headerlink" title="AMOEBA"></a>AMOEBA</h4><p>AMOEBA极化力场提供蛋白质，水和离子的参数。</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Parameters</th>
</tr>
</thead>
<tbody><tr>
<td><code>amoeba2013.xml</code></td>
<td>AMOEBA 2013<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#shi2013">[12]</a></td>
</tr>
<tr>
<td><code>amoeba2013_gk.xml</code></td>
<td>Generalized Kirkwood solvation model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#schnieders2007">[13]</a> for use with AMOEBA 2013 force field</td>
</tr>
<tr>
<td><code>amoeba2009.xml</code></td>
<td>AMOEBA 2009<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#ren2002">[14]</a>. This force field is deprecated. It is<br>recommended to use AMOEBA 2013 instead.</td>
</tr>
<tr>
<td><code>amoeba2009_gk.xml</code></td>
<td>Generalized Kirkwood solvation model for use with AMOEBA 2009 force field</td>
</tr>
</tbody></table>
<h4 id="Water-Models"><a href="#Water-Models" class="headerlink" title="Water Models"></a>Water Models</h4><p>以下文件定义了流行的水模型。 它们可以与不提供自己的水模型的力场一起使用。 使用Amber14或CHARMM36时，请改用那些力场附带的水文件，因为它们也包含离子参数。</p>
<table>
<thead>
<tr>
<th>File</th>
<th>Water Model</th>
</tr>
</thead>
<tbody><tr>
<td>tip3p.xml</td>
<td>TIP3P water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#jorgensen1983">[2]</a></td>
</tr>
<tr>
<td>tip3pfb.xml</td>
<td>TIP3P-FB water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#wang2014">[3]</a></td>
</tr>
<tr>
<td>tip4pew.xml</td>
<td>TIP4P-Ew water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#horn2004">[4]</a></td>
</tr>
<tr>
<td>tip4pfb.xml</td>
<td>TIP4P-FB water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#wang2014">[3]</a></td>
</tr>
<tr>
<td>tip5p.xml</td>
<td>TIP5P water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#mahoney2000">[9]</a></td>
</tr>
<tr>
<td>spce.xml</td>
<td>SPC/E water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#berendsen1987">[5]</a></td>
</tr>
<tr>
<td>swm4ndp.xml</td>
<td>SWM4-NDP water model<a href="http://docs.openmm.org/latest/userguide/zbibliography.html#lamoureux2006">[23]</a></td>
</tr>
</tbody></table>
<h3 id="小分子参数"><a href="#小分子参数" class="headerlink" title="小分子参数"></a>小分子参数</h3><p>上面的OpenMM力场包括用于大分子和溶剂的预生成模板。 如果系统包含小分子，则通常需要即时生成这些参数。</p>
<p>在OpenMM生态系统中，有两种方法可以执行此操作：</p>
<ul>
<li>Small molecule residue template generators（小分子残基模版生产器）一种方法是对openmmforcefields conda软件包中的小分子使用残基模板生成器。 您可以通过conda安装此程序：<code>$ conda install -c conda-forge openmmforcefields</code>然后，可以使用Open Force Field Initiative小分子力场（通过以下示例）添加小分子残基模板生成器：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从benzene的smiles中创建一个 openforcefield Molecule object</span></span><br><span class="line"><span class="keyword">from</span> openforcefield.topology <span class="keyword">import</span> Molecule</span><br><span class="line">molecule = Molecule.from_smiles(<span class="string">&#x27;c1ccccc1&#x27;</span>)</span><br><span class="line"><span class="comment">#使用 Open Force Field Initiative小分子力场 来创建 the SMIRNOFF template generator </span></span><br><span class="line"><span class="keyword">from</span> openmmforcefields.generators <span class="keyword">import</span> SMIRNOFFTemplateGenerator</span><br><span class="line"><span class="keyword">from</span> simtk.openmm.app <span class="keyword">import</span> ForceField</span><br><span class="line">smirnoff = SMIRNOFFTemplateGenerator(molecules=molecule)</span><br><span class="line"><span class="comment"># 使用AMBER ff14SB and TIP3P创建一个OpenMM ForceField object </span></span><br><span class="line">forcefield = ForceField(<span class="string">&#x27;amber/protein.ff14SB.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_standard.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_HFE_multivalent.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># 注册一个SMIRNOFF 模版生成器</span></span><br><span class="line">forcefield.registerTemplateGenerator(smirnoff.generator)</span><br></pre></td></tr></table></figure>

同样的，你也可以使用<a href="http://ambermd.org/antechamber/gaff.html">AMBER GAFF small molecule force field</a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从benzene的smiles中创建一个 openforcefield Molecule object</span></span><br><span class="line"><span class="keyword">from</span> openforcefield.topology <span class="keyword">import</span> Molecule</span><br><span class="line">molecule = Molecule.from_smiles(<span class="string">&#x27;c1ccccc1&#x27;</span>)</span><br><span class="line"><span class="comment">#创建以一个GAFF模版生成器</span></span><br><span class="line"><span class="keyword">from</span> openmmforcefields.generators <span class="keyword">import</span> GAFFTemplateGenerator</span><br><span class="line">gaff = GAFFTemplateGenerator(molecules=molecule)</span><br><span class="line"><span class="comment"># 使用AMBER ff14SB and TIP3P创建一个OpenMM ForceField object </span></span><br><span class="line"><span class="keyword">from</span> simtk.openmm.app <span class="keyword">import</span> ForceField</span><br><span class="line">forcefield = ForceField(<span class="string">&#x27;amber/protein.ff14SB.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_standard.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_HFE_multivalent.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># 注册一个 GAFF 模版生成器</span></span><br><span class="line">forcefield.registerTemplateGenerator(gaff.generator)</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数化包含有特定分子的 OpenMM Topology object </span></span><br><span class="line"><span class="comment"># forcefield 将会导入正确的 GAFF parameters</span></span><br><span class="line"><span class="comment"># 产生参数</span></span><br><span class="line"><span class="comment"># pdb:https://www.rcsb.org/structure/4W52</span></span><br><span class="line">pdbfile = PDBFile(<span class="string">&#x27;4w52.pdb&#x27;</span>)</span><br><span class="line">system = forcefield.createSystem(pdbfile.topology)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SystemGenerator</code>来操纵力场  openmm forcefields软件包提供了SystemGenerator工具来简化大分子和小分子力场管理。 要使用此功能，只需指定要使用的小分子力场即可：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> simtk <span class="keyword">import</span> unit</span><br><span class="line"><span class="keyword">from</span> simtk.openmm <span class="keyword">import</span> app</span><br><span class="line"><span class="keyword">from</span> openmmforcefields.generators <span class="keyword">import</span> SystemGenerator</span><br><span class="line"><span class="keyword">from</span> openforcefield.topology <span class="keyword">import</span> Molecule</span><br><span class="line">forcefield_kwargs = &#123; <span class="string">&#x27;constraints&#x27;</span> : app.HBonds, <span class="string">&#x27;rigidWater&#x27;</span> : <span class="literal">True</span>, <span class="string">&#x27;removeCMMotion&#x27;</span> : <span class="literal">False</span>, <span class="string">&#x27;hydrogenMass&#x27;</span> : <span class="number">4</span>*unit.amu &#125;</span><br><span class="line"><span class="comment"># Initialize a SystemGenerator using the Open Force Field Initiative 1.2.0 force field (openff-1.2.0)</span></span><br><span class="line">system_generator = SystemGenerator(forcefields=[<span class="string">&#x27;amber/ff14SB.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_standard.xml&#x27;</span>], small_molecule_forcefield=<span class="string">&#x27;openff-1.2.0&#x27;</span>, forcefield_kwargs=forcefield_kwargs, cache=<span class="string">&#x27;db.json&#x27;</span>)</span><br><span class="line"><span class="comment"># Create an OpenMM System from an OpenMM Topology object and a list of openforcefield Molecule objects</span></span><br><span class="line">molecules = Molecule.from_file(<span class="string">&#x27;molecule.sdf&#x27;</span>, file_format=<span class="string">&#x27;sdf&#x27;</span>)</span><br></pre></td></tr></table></figure>

SystemGenerator会将在Molecular.sdf中找到的分子的任何实例与出现在拓扑中的那些实例进行匹配。 请注意，质子化和互变异构状态必须在读取的分子与出现在拓扑结构中的分子之间完全匹配。 有关更多详细信息，请参见openmmforcefields文档。<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create an OpenFF Molecule object for benzene from SMILES</span></span><br><span class="line"><span class="keyword">from</span> openforcefield.topology <span class="keyword">import</span> Molecule</span><br><span class="line">molecule = Molecule.from_smiles(<span class="string">&#x27;c1ccccc1&#x27;</span>)</span><br><span class="line"><span class="comment"># Create the SMIRNOFF template generator with the default installed force field (openff-1.0.0)</span></span><br><span class="line"><span class="keyword">from</span> openmmforcefields.generators <span class="keyword">import</span> SMIRNOFFTemplateGenerator</span><br><span class="line">smirnoff = SMIRNOFFTemplateGenerator(molecules=molecule, forcefield=<span class="string">&#x27;openff-1.2.0&#x27;</span>)</span><br><span class="line"><span class="comment"># Create an OpenMM ForceField object with AMBER ff14SB and TIP3P with compatible ions</span></span><br><span class="line"><span class="keyword">from</span> simtk.openmm.app <span class="keyword">import</span> ForceField</span><br><span class="line">forcefield = ForceField(<span class="string">&#x27;amber/protein.ff14SB.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_standard.xml&#x27;</span>, <span class="string">&#x27;amber/tip3p_HFE_multivalent.xml&#x27;</span>)</span><br><span class="line"><span class="comment"># Register the SMIRNOFF template generator</span></span><br><span class="line">forcefield.registerTemplateGenerator(smirnoff.generator)</span><br><span class="line"><span class="comment"># 参数化包含有特定分子的 OpenMM Topology object </span></span><br><span class="line"><span class="comment"># forcefield 将会导入正确的 GAFF parameters</span></span><br><span class="line"><span class="comment"># 产生参数</span></span><br><span class="line"><span class="comment"># pdb:https://www.rcsb.org/structure/4W52</span></span><br><span class="line">pdbfile = PDBFile(<span class="string">&#x27;4w52.pdb&#x27;</span>)</span><br><span class="line">system =forcefield.createSystem(pdbfile.topology)</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>OpenMM</category>
      </categories>
  </entry>
  <entry>
    <title>一篇综述一个领域｜在药物发现中的对接以及打分：方法以及应用</title>
    <url>/2021/02/11/paper/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E4%B8%80%E4%B8%AA%E9%A2%86%E5%9F%9F%EF%BD%9C%E5%9C%A8%E8%8D%AF%E7%89%A9%E5%8F%91%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%89%93%E5%88%86%EF%BC%9A%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前沿："><a href="#前沿：" class="headerlink" title="前沿："></a>前沿：</h3><p>在药物发现领域，CADD技术可以加速药物研发，而CADD又下分为SBDD，LBDD，FBDD，以及最近大热的AIDD。在SBDD领域，DOCKING始终是绕不开的话题，也是高通量虚拟筛选的利器，本文通过一篇综述，来尽可能的将DOCKING这一概念阐释清晰。</p>
<h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>将小分子“停靠”到大分子靶标结构中并“得分”其与结合位点的潜在互补性的计算方法被广泛用于命中鉴定和前导优化。 确实，现在有许多药物的开发受到诸如基于结构的设计和筛选策略的影响或基于结构的设计和筛选策略，例如HIV蛋白酶抑制剂。 然而，在应用这些方法时，尤其是在当前评分方案方面，仍然存在重大挑战。 在这里，我们回顾了小分子蛋白质对接方法的关键概念和特定功能，重点介绍了选定的应用，并讨论了旨在解决公认方法的局限性的最新进展。</p>
<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gnigqsyysbj31by0jkq6n.jpg" alt="image-20210210151943996"></p>
<h3 id="DOCKING简介"><a href="#DOCKING简介" class="headerlink" title="DOCKING简介"></a>DOCKING简介</h3><p>DOCKING过程涉及预测目标结合位点内的配体构象和方向（或姿势posing）（方框1）。 </p>
<p>通常，其有两个目标：准确的结构建模和正确的活性预测。 </p>
<p>DOCKING通常设计为一个多步骤过程，其中每个步骤都引入了一个或多个程度的复杂性。</p>
<p>该过程始于对接算法的应用，该算法将小分子定位在活性位点。这本身就具有挑战性，因为即使<strong>相对简单的有机分子也可以包含许多构象自由度</strong>。必须以足够的精度对这些自由度进行采样，以识别与受体结构最匹配的构象，并且<strong>必须足够快</strong>，以允许在一定的时间内可以评估大量的化合物。</p>
<p>评分功能对算法进行了补充，评分功能旨在通过评估化合物与潜在靶标之间的相互作用来预测生物活性。早期的评分函数根据<strong>形状和静电互补性</strong>的计算来评估。通常使用更复杂的评分方案，对<strong>静电和范德华</strong>相互作用进行更详细的处理，并至少包含一些<strong>溶剂或熵效应</strong>，对构象异构体进行进一步评估。</p>
<p>还应注意的是，配体受体之间的结合是由<strong>焓和熵效应</strong>共同驱动的，并且熵或焓都可以主导特定的相互作用。这为打分提出一个概念性问题，因为它们中的大多数更着重于<strong>能量变化而不是熵效应</strong>。</p>
<p>除了与化合物构象评分相关的问题外，还存在其他复杂因素，这使得准确预测复合物构象和化合物活性变得更加具有挑战性。</p>
<p>这些因素包括：<strong>结构的分辨率有限，配体灵活性，诱导契合性或结合时发生的其他构象变化，以及水分子是否参与</strong>。</p>
<p><strong>对接的理论方面</strong></p>
<p>对于酶和抑制剂，对接的目的是在平衡条件下正确预测复合物[E + I] = [EI]的结构。</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210155915170.png" alt="image-20210210155915170" style="zoom:50%;" />



<p>该图说明了抑制剂Dmp323与HIV蛋白酶的结合，并已有复合物结构（PDB代码：1BVE）。 酶与抑制剂的多重复合物结构仅显示出有限的结构变化。</p>
<p>结合的自由能（∆G）与结合亲和力的关系式如下：</p>
<img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210160310541.png" alt="image-20210210160310541" style="zoom:50%;" />

<p>预测[E + I]配合物的正确结构（posing）不需要有关K<sub>A</sub>的信息。 但是，生物活性的预测（ranking）需要此信息。 因此，打分项可以按以下方式划分。 当考虑[EI]时，以下因素很重要：空间，静电，氢键，配体灵活度和配体灵活度。 当考虑方程式1所示的平衡过程时，以下因素也很重要：去溶剂化，旋转熵和平移熵。</p>
<blockquote>
<p>1BVE:Dmp323与HIV蛋白酶的复合物结构，在众多HIV蛋白酶与复合物的晶体结构已被解析出的环境下，这是第一个被解析出的HIV蛋白酶抑制剂溶剂条件下的复合物结构（NMR），得到了计算出28个NMR结构的集合，忽略无序环中的残基，结构集合中主链原子与平均结构的偏差（RMSD）在0.60埃。</p>
</blockquote>
<h3 id="对接过程中的分子展示（Molecular-representations-for-docking）"><a href="#对接过程中的分子展示（Molecular-representations-for-docking）" class="headerlink" title="对接过程中的分子展示（Molecular representations for docking）"></a>对接过程中的分子展示（Molecular representations for docking）</h3><p>为了评估各种对接方法，重要的是要考虑蛋白质和配体的展示方式。</p>
<p>一般来说，有三种基本展示形式：原子（ATOM），表面（SURFACE）和网格（GRID）。</p>
<p>其中，原子展示法通常仅与势能函数一起使用，并且通常仅在最终的RANKING过程中使用（由于评估成对原子相互作用的计算复杂度）。</p>
<blockquote>
<p>在这里，作者主要参考了这篇文章DARWIN: a program for docking flexible molecules ，目前，我尚未从scihub上下载下来，但是从其简介中，我们可以知道，DARWIN与CHARMM进行联用从而进行能量计算，也即为在最终的RANKING阶段继续评估成对原子相互作用计算。</p>
</blockquote>
<p>基于表面的对接程序通常）用于蛋白质-蛋白质对接。康诺利（Connolly）在分子surface表征方面的工作十分重要。这些方法试图通过最小化相对分子表面之间的角度来对齐表面上的点。因此，刚体对接仍然是许多蛋白质-蛋白质对接技术的标准。</p>
<p>Goodford率先使用了grid展示，并且随后各种对接程序都使用这种网格表示进行能量计算。基本思想是将有关受体能量贡献的信息存储在网格点上，以便仅在计分过程中才需要读取它。在最基本的形式中，网格点存储两种类型的电势：静电和范德华力。</p>
<blockquote>
<p>静电势能表示为库仑相互作用的成对总和</p>
<p>在等式1中，N分别是分子A和B中的原子数，q是每个原子上的电荷。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210171401797.png" alt="image-20210210171401797"></p>
<p>对于非键相互作用的一般处理，范德华势能通常由Lennard–Jones 12–6式进行建模，如公式2所示：</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210171543178.png" alt="image-20210210171543178"></p>
<p>在等式2中，ε是电势的阱深度，而σ是原子i和j的碰撞直径。</p>
<p>下图显示了Lennard–Jones 12–6式。 该方程式的exp（12）项负责小距离斥力，而exp（6）负责吸引力。当两个原子之间的距离增加时，范德华势能趋近于零。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210171654778.png" alt="image-20210210171654778"></p>
</blockquote>
<blockquote>
<p>红色：负电；蓝色：正电。</p>
<p>图a示出了活性位点附近的静电势表面，而图b示出了围绕在抑制剂周围的受体部分静电势表面（存在cut-away）。</p>
</blockquote>
<blockquote>
<p>抑制剂Dmp323与HIV蛋白酶（PDB：1BVE）形成复合物。 </p>
<p>将抑制剂的静电势映射到分子表面上，HIV蛋白酶中的残基Ile50和Asp25可稳定抑制剂的结合。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210165635174.png" alt="image-20210210165635174"></p>
</blockquote>
<h3 id="搜寻手段与配体灵活性（Search-methods-and-molecular-flexibility）"><a href="#搜寻手段与配体灵活性（Search-methods-and-molecular-flexibility）" class="headerlink" title="搜寻手段与配体灵活性（Search methods and molecular flexibility）"></a>搜寻手段与配体灵活性（Search methods and molecular flexibility）</h3><p>本节重点介绍用于处理配体灵活性以及蛋白质灵活度的算法。</p>
<p> 配体灵活度的处理可分为三个基本类别：</p>
<ol>
<li><p>系统方法（增量构建，构象搜索，数据库）； </p>
</li>
<li><p>随机或随机方法（蒙特卡洛，遗传算法，禁忌搜索）；</p>
</li>
<li><p> 和模拟方法（分子动力学，能量最小化）。 </p>
</li>
</ol>
<p>相关总结如下：</p>
<p>   <img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210171851378.png" alt="image-20210210171851378"></p>
<h4 id="系统搜索（Systematic-search）"><a href="#系统搜索（Systematic-search）" class="headerlink" title="系统搜索（Systematic search）"></a>系统搜索（Systematic search）</h4><p>这些算法试图探索配体中的所有自由度，但最终面临组合爆炸的问题。 因此，配体在活性位点通常逐渐生长。 一般采用逐步搜索或增量搜索，例如，将各种分子片段对接到活性位点区域，然后将它们共价连接（这是从头开始的配体设计策略），或者，通过将对接的配体分为刚性（核心片段）和柔性部分（侧链）。在后一种情况下，将刚性片段对接到活动位置。接下来，以递增方式添加柔性片段。例如，DOCK 通过空间互补性构成了核心片段，通过系统地探索每个键的位姿空间，使柔性侧链一次增长一个键。并且应用修剪算法尽早删除不利的构象，从而降低了复杂性。 FlexX与DOCK的不同之处在于，刚性核心片段的放置基于片段与受体之间的相互作用基团。相互作用基团主要是氢键供体和受体，以及疏水基团。 FlexX与DOCK的不同之处还在于，它使用POSE聚类算法对POSE进行分类。 </p>
<p>与其他增量搜索算法一样，Hammerhead算法仍然将配体划分为多个片段。 但是，Hammerhead会对每个片段进行对接，然后从可接受的片段中开始重建配体。 在碎片生长阶段，每次新添加后都会进行能量最小化。</p>
<p>系统搜索的另一种方法是使用预先生成的构象库。 库中的构象通常只计算一次，因此搜索问题可简化为刚体对接过程。 例如，FLOG根据距离几何图形生成配体构象库。 一旦产生了可接受的构象，算法便以类似于DOCK的方式对其进行探索。</p>
<p><strong>组合爆炸问题</strong></p>
<p>对于系统构象搜索，可能的分子构象数由等式1表示</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210213602916.png" alt="image-20210210213602916"></p>
<p>在等式1中，N是可旋转键的数量，θ<sub> i </sub>,<sub>j</sub>是对键i的旋转角j。 为了避免详尽的搜索计算，许多构象搜索算法使用增量构建方法在活动位点内生长配体，该过程包括三个基本步骤：</p>
<ol>
<li><p>核心片段选择。</p>
</li>
<li><p>核心片段放置。</p>
</li>
<li><p> 增量配体构建。</p>
</li>
</ol>
<p>   在第一步中，配体分为刚性核片段和柔性侧链。 随后，这些侧链在每个新的可旋转键处进一步分开，如图所示。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210213706564.png" alt="image-20210210213706564"></p>
<p>在第二步和第三步中，首先放置核心片段和随后侧链增量连接并进行旋转。</p>
<h4 id="随机探索（Random-search）"><a href="#随机探索（Random-search）" class="headerlink" title="随机探索（Random search）"></a>随机探索（Random search）</h4><p>这些算法（通常称为随机搜索）通过对单个配体构象或配体构象群体进行随机更改来进行操作。 根据预先定义好的概率函数评估新获得的配体构象是否被接受。 两种比较流行的随机方法是蒙特卡洛和遗传算法。 蒙特卡罗搜索的实现方式在AutoDock中已有实现。其他几个程序（包括DOCK和GOLD）也实现了遗传算法。</p>
<p>禁忌搜索算法（abu search algorithm）的基本思想是考虑已探究的构象空间区域。 为了确定分子构象是否被接受，需要计算当前分子坐标与每个分子先前记录的构象之间的均方根偏差。 例如，PRO_LEADS使用禁忌搜索算法。</p>
<h4 id="分子模拟（-Simulation-methods-）："><a href="#分子模拟（-Simulation-methods-）：" class="headerlink" title="分子模拟（*Simulation methods.*）："></a>分子模拟（*Simulation methods.*）：</h4><p>分子动力学是目前最流行的模拟方法。 但是，分子动力学模拟通常无法在可行的模拟时间内越过高能壁垒，经常结果为局部最小值。 因此，一种解决思路是尝试在不同温度下模拟蛋白质-配体系统的不同部分。 另一种策略是从不同的配体位置开始分子动力学计算。 与分子动力学相反，能量最小化方法很少用作独立的搜索手段，因为此技术手段只能达到局部能量的最小值，但通常是对其他搜索方法（包括蒙特卡洛）的补充。 每次添加片段后，DOCK都会执行最小化步骤，然后在打分之前进行整体最小化。</p>
<p><strong>搜索技术</strong></p>
<ol>
<li>基本的蒙特卡洛算法<ol>
<li>在活性位点中间，随机产生配体构象做为初始构型。</li>
<li> 对初始构型进行打分。</li>
<li> 生成新构型并为其打分（或许随机，或许基于某些知识经验）。</li>
<li> 使用大都会标准来确定新构型进行打分。</li>
<li> 重复前面的步骤，直到获得所需数量的构型。</li>
</ol>
</li>
</ol>
<ul>
<li>大都会标准(Metropolis criterion)<pre><code>如果构型的得分优于以前的构型，则立即接受。如果构型不是新的最小值，则基于Boltzmann的概率函数。如果构型通过了概率函数，则被接受；如果不是，则新构型被拒绝。
</code></pre>
</li>
</ul>
<ol start="2">
<li><p>分子动力学<br>分子动力学是一种模拟技术，可以解决原子系统的牛顿运动方程：Fi = mi ai，其中F是力，m是质量，a是加速度。</p>
<p>根据当前位置和新位置之间的势能变化（通常基于分子力学术语）来计算作用在每个原子上的力：Fi = –（dE / ri），其中r为距离。然后使用原子力和质量来确定一系列非常小的时间步长上的原子位置：Fi = mi（d2ri / dt2），其中t是时间。</p>
<p>这提供了原子位置随时间变化的轨迹。</p>
<p>实际上，通过首先根据力和质量计算加速度ai，然后根据ai = dvi / dt来计算速度vi，最终根据速度vi = dri / dt来计算位置，更容易确定与时间有关的原子位置。</p>
</li>
<li><p>遗传算法<br>遗传算法是一类基于生物竞争和种群动态原理的解决策略，其基本原理很容易理解，相关研究也很多。</p>
<p>下面这幅图只是一种基本展示，来源于百度。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/format,f_auto-20210211134030316.jpeg" alt="img"></p>
<p>对于对接来说，遗传算法最后的产生结果是可能的配体构象的集合。</p>
</li>
<li><p>禁忌搜索算法</p>
<ol>
<li><p>对当前构象进行n次小的随机更改。</p>
</li>
<li><p>根据所选适应度函数对每个变化之后的构象进行排名。</p>
</li>
<li><p>确定哪些更改是“禁忌”（即以前拒绝的构型）。</p>
</li>
<li><p>如果最佳修改的价值比目前为止接受的其他修改要低，则即使它在“ tabu”中，也要接受；否则，请接受最佳的“非禁忌”更改。</p>
</li>
<li><p>将接受的更改添加到“ tabu”列表中并记录其得分。</p>
</li>
<li><p>转到第一步。</p>
<p>well，这里有些难理解，按照我的思考来说，设置‘tabu’列表，即为禁忌的旋转角度，随机产生n次小的<strong>更改</strong>之后，首先对这些<strong>更改</strong>进行确认，辨别出哪些更改为禁忌的。如果最优的更改策略比其余接受的值低，那么即便此更改在“ tabu”中，也要接受此更改；否则的话，接受最佳的“非禁忌”更改。然后，将接受的更改添加到“ tabu”列表。</p>
</li>
</ol>
</li>
</ol>
<h4 id="蛋白灵活性（-Protein-flexibility-）"><a href="#蛋白灵活性（-Protein-flexibility-）" class="headerlink" title="蛋白灵活性（*Protein flexibility.*）"></a>蛋白灵活性（*Protein flexibility.*）</h4><p>相比较而言，蛋白质灵活度的处理没有配体灵活度的先进，但是已经应用了各种方法来灵活地对目标的至少一部分进行建模，包括分子动力学和蒙特卡洛计算，旋转异构体和蛋白质集合网格。使用<strong>氨基酸侧链旋转异构体文库</strong>的想法是基于有限数量的实验观察到的和优选的侧链构象对蛋白质构象空间建模。为了减少由旋转异构体的组合产生的离散蛋白质构象的数量，通常使用无末端消除算法（dead-end elimination algorithm）。该算法递归地删除了对最小能量结构无贡献的侧链构象。处理蛋白质灵活度的另一种方法是<strong>使用蛋白质构象的集合体（而不是单个）</strong>作为对接的目标。DOCK中实现的为生成了集合的平均势能网格；另一种则是单独对组内存在的受体-配体构象进行打分。</p>
<h3 id="打分（Scoring）"><a href="#打分（Scoring）" class="headerlink" title="打分（Scoring）"></a>打分（Scoring）</h3><p>对预测出的配体构象与受体的评估和排名是十分重要的。即使正确预测了结合构象，如果不能将正确的POSE与不正确的POSE区分开，如果无法识别“真实”的配体，则计算最终仍然是失败的。</p>
<p>因此，设计可靠的评分功能和方案至关重要。已经开发了自由能模拟技术，用于蛋白质-配体相互作用的定量建模和结合亲和力的预测。但是，这些计算太过耗时，对于评估大量蛋白质-配体复合物仍然不切实际，而且计算并不总是准确的。对接程序中实现的评分功能在评估复合物时做出了各种假设和简化，并且没有完全考虑到许多影响分子识别的物理因素，例如熵效应。</p>
<p>基本上，目前存在三种类型打分函数：基于力场；基于经验；基于知识。</p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210210174737050.png" alt="image-20210210174737050"></p>
<h4 id="基于力场的打分（Force-field-based-scoring）："><a href="#基于力场的打分（Force-field-based-scoring）：" class="headerlink" title="基于力场的打分（Force-field-based scoring）："></a>基于力场的打分（<em>Force-field-based scoring</em>）：</h4><p>这些打分函数基于物理,分子力学力场通常量化为两个能量的总和，即受体-配体相互作用能和配体内部能量（例如结合引起的空间变化）。图3说明了分子识别中涉及的非键相互作用的力场模型。大多数力场评分功能仅考虑单个蛋白质构象，从而可以省略蛋白质内部能量的计算，大大简化了评分。各种力场评分功能均基于不同的力场参数集。例如，基于Tripos力场的G-Score和基于AMBER力场的AutoDock。但是，函数形式通常是相似的。</p>
<p>标准力场打分函数具有局限性，因为它们最初是为模拟焓气相对结构和能量的贡献而制定的，并且不包括溶剂化和熵项。 基于力场的评分因以下事实而变得更加复杂：通常需要引入截止距离来处理非键合相互作用，这种距离或多或少是任意选择的，这会使长距离的精确处理变得复杂。</p>
<blockquote>
<p><img src="/Users/sujiaqi/Desktop/Personal/MyNote/%E4%B8%80%E7%AF%87%E7%BB%BC%E8%BF%B0%E4%B8%80%E4%B8%AA%E9%A2%86%E5%9F%9F%EF%BD%9C%E5%9C%A8%E8%8D%AF%E7%89%A9%E5%8F%91%E7%8E%B0%E4%B8%AD%E7%9A%84%E5%AF%B9%E6%8E%A5%E4%BB%A5%E5%8F%8A%E6%89%93%E5%88%86%EF%BC%9A%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8.assets/image-20210211135344147.png" alt="image-20210211135344147">a|抑制剂BIRB796与其复合物结构（PDB：1KV2）。所显示的抑制剂具有其静电势能表面。 b |活性位点的放大视图。 c |残基Glu71与BIRB796之间相互作用的特写视图。氢键和范德华相互作用分别用红色和绿色标记。 d |用于建模有助于绑定的成对交互的功能的示意图。根据两个原子i和j之间的距离（rij）计算相互作用。 d部分的左侧：由12–6 Lennard-Jones势给出的范德华相互作用。 d部分的中部：由12-10 Lennard-Jones势赋予的氢键势，与角度有关（如c所示）。 d部分的右边：使用4r随距离变化的介电常数计算出的两个大小相同的（蓝色）或相反（黑色）电荷的静电势。</p>
</blockquote>
<h4 id="基于经验的打分函数（-Empirical-scoring-functions-）"><a href="#基于经验的打分函数（-Empirical-scoring-functions-）" class="headerlink" title="基于经验的打分函数（*Empirical scoring functions.*）"></a>基于经验的打分函数（*Empirical scoring functions.*）</h4><p>这些评分函数适合重现实验数据，例如结合能和/或构象，这是几个参数化函数的总和，这是Böhm首先提出的。经验打分函数的设计基于如下思想，即结合能可以通过各个不相关项的总和来近似。使用实验确定的结合能和结构信息，利用回归分析获得各种项的系数。经验打分函数形式通常比力场打分函数更简单。经验函数的吸引力在于，<strong>它们的各种项通常易于化学家或者实验人员进行评估优化</strong>，但它们基于类似于力场函数的近似值。这些方法的缺点是它们依赖于用于进行拟合的<strong>分子数据集</strong>，这通常会产生不同的加权因子，来自不同拟合得分函数的项不能重新组合为新的打分函数。</p>
<h4 id="基于知识的打分函数（Knowledge-based-scoring-functions-）"><a href="#基于知识的打分函数（Knowledge-based-scoring-functions-）" class="headerlink" title="基于知识的打分函数（Knowledge-based scoring functions. ）"></a>基于知识的打分函数（<em>Knowledge-based scoring functions.</em> ）</h4><p>基于知识的评分功能旨在重现实验结构，而不是计算能量。在基于知识的打分函数中，使用相对简单的原子之间相互作用对蛋白质-配体复合物进行建模。根据原子所处的环境，定义了许多原子类型的相互作用。因此，与经验方法一样，基于知识的评分函数试图隐式捕获难以显式建模的项。此类打分函数比较流行的有：POTENTIAL OF MEAN FORCE（PMF）和DrugScore。许多基于知识的评分功能的主要吸引力在于它们的计算简单性，可以有效地筛选大型化合物数据库。缺点是它们的推导基本上基于隐式编码的蛋白质-配体复杂结构的有限集合中的信息。</p>
<h4 id="共识函数（Consensus-scoring）"><a href="#共识函数（Consensus-scoring）" class="headerlink" title="共识函数（Consensus scoring）"></a>共识函数（<em>Consensus scoring</em>）</h4><p>考虑到当前打分函数的不完善，该领域的最新趋势是引入共识评分方案。 共识评分结合了不同打分函数的信息，以减少单个评分中的错误，并提高了识别“真实”配体的可能性。 共识评分的实现是X-CSCORE，它结合了GOLD类似，DOCK类似，ChemScore，PMF和FlexX打分函数。 但是，如果不同打分函数中的某些项显着相关，则可能会放大计算误差，而不是减少错误。</p>
<h4 id="POSE和打分（Posing-versus-scoring）"><a href="#POSE和打分（Posing-versus-scoring）" class="headerlink" title="POSE和打分（Posing versus scoring）"></a>POSE和打分（<em>Posing versus scoring</em>）</h4><p>计算错误是否与结合构象预测或打分有关？配体的灵活度比配体尺寸或极性对结果的影响更大，这显然与POSING有关。但是，区分“幻想”配体和“真实”配体的能力关键取决于打分函数。通常很难区分是构象搜索不充分还是打分函数有缺陷，并且此类相关的研究相对较少。</p>
<p>在各种对接程序中，在针对射线构象时， DOCK，FlexX和GOLD显示出明显的优势，即配体比任何不正确的构象都得分更高，即可以很容易的获取真实构象，而CDOCKER通常对正确结构的打分更差。就结构精度而言，在一组69组复合物的训练集上，GOLD和Glide的总体结果令人满意。在对GOLD的重新参数化中，比较了两种打分函数GOLDSCORE和ChemScore，并将其应用于共识评分方案中。两种打分均获得了相似的评分准确性（65–85％）。</p>
<p>结合亲和力的预测取决于能否找到正确的结合构象。作为共识评分的替代方法，引入了基于遗传算法的评分项，以更好地从“噪声”化合物中获得正确的配体。在这些基础上，得出结论，对复合物构象进行精准的建模是必要的，但仍然不足以进行正确的配体评分和排名。 考虑到各种结构预测工作的成功率，打分函数的缺陷仍然是主要的限制因素。</p>
<h4 id="提升打分函数（Improving-scoring-functions-）"><a href="#提升打分函数（Improving-scoring-functions-）" class="headerlink" title="提升打分函数（Improving scoring functions. ）"></a>提升打分函数（<em>Improving scoring functions.</em> ）</h4><p>如何进一步提高打分函数的质量？如前所述，该领域的当前趋势是将重点放在各种溶剂化和旋转熵的贡献上。计入此类贡献的打分比标准的力场函数更准确，但计算量也很大，这给高通量对接带来了挑战。更重要的是，经常观察到的更改之后的打分函数在多个目标上的表现差异很大，例如，GOLD验证集。这表明开发出通用打分函数可能很困难。蛋白结合位点和配体识别过程都是独特的，这些特性最终使蛋白质与配体之间的相互作用变得独一无二，而其结论则是可能经常需要根据具体情况对评分方案进行“调整”。</p>
<h3 id="基于结构的虚拟筛选（Structure-based-virtual-screening）"><a href="#基于结构的虚拟筛选（Structure-based-virtual-screening）" class="headerlink" title="基于结构的虚拟筛选（Structure-based virtual screening）"></a>基于结构的虚拟筛选（Structure-based virtual screening）</h3><p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210211125942231.png" alt="image-20210211125942231"></p>
<blockquote>
<p>蛋白质-配体相互作用的复杂性。 该图显示了复合物结构中相互作用的示意图，需要考虑这些相互作用才能预测同一活性位点内两种化合物的连接构象和结合能。</p>
<p> 在这种情况下，将环AMP依赖性激酶（PDB代码：1atp）的天然辅助因子Mg-ATP与抑制剂星形孢菌素进行了比较。 为了在对接研究中可以更正确将星形孢菌素挑出，用于疏水性（吲哚），氢键（内酰胺环）和离子性（脂族胺盐桥，磷酸镁+蛋白质螯合）相互作用的能量函数必须进行适当调整权重以进行优化。</p>
<p> 为特定目标寻找优选的打分函数是一项艰巨的过程，通常涉及许多试验。</p>
</blockquote>
<h4 id="一般警告"><a href="#一般警告" class="headerlink" title="一般警告"></a>一般警告</h4><p>无论使用何种打分函数，分数随着分子质量和化合物中可旋转键的数量而缩放比例都很差。大分子可以在结合位点上形成许多假设的相互作用，因此比小分子化合物倾向于产生更好的分数。另一方面，固定不动旋转键的熵代价（通常不考虑）与此类键的数量成比例。结果，如果包括熵罚，则柔性分子的得分往往低于刚性分子。此外，分子姿势的内部应变能通常以配体的单个未结合构象作为参照而近似，这在估计结合时的熵和焓损失方面具有明显的局限性。这些限制通常会增加评分功能的缺陷，并使得根据计算的结合位点相互作用准确地对测试分子进行排名变得更加困难。<br>活性位点的一般性质和制备也影响配体位置和得分的质量。例如，在HIV蛋白酶中发现的疏水性结合位点可能比亲水性更高的位点或结合事件涉及的静电相互作用（例如在金属酶中发现）更有望成为目标。这主要是由于这样的事实，即可以通过计算配体与受体之间的形状互补性来很好地估计与疏水位点的结合，自对接初期以来，就已经存在强大的方法[8,77]。形状互补性的计算隐含考虑了疏水作用。但是，疏水性作用的很大（有时是最大的）贡献来自疏水性配体的去溶剂化作用（例如在HIV蛋白酶中），这在对接分数中并未得到充分考虑，相对于其他得分项，它可能被大大低估了。在一些活动站点中。此外，静电相互作用的精确建模和评分仍然是当代评分功能的主要挑战。如上所述，在许多情况下，简单的库仑模型仍被用于这些目的，并且倾向于严重高估电荷-电荷相互作用或产生人为的相互作用。<br>此外，在结构上很重要或直接参与结合相互作用的水分子的放置，以及假定结合位点内侧链构象的刚性，都可以极大地影响测试化合物的形成78。显然，每当结合中发生构象变化时，严格定义的结合位点的预测潜能就会受到限制。最后，已经观察到，基于结构的虚拟筛选通常会选择生物混杂的化合物，因此被称为“频繁击球者” 79,80。此类化合物相当非特异性的抑制作用至少可以部分归因于疏水特性和聚集效应的主导作用，这些倾向倾向于在对接模拟和筛选测定中都有利于检测（尽管出于不同的原因）。</p>
<h4 id="选择策略（-Selection-strategies-）"><a href="#选择策略（-Selection-strategies-）" class="headerlink" title="选择策略（*Selection strategies.*）"></a>选择策略（*Selection strategies.*）</h4><p>考虑到系统设置，POSING和打分中涉及的许多近似和局限性，人们可能会问为什么基于结构的虚拟筛选实际上可以“起作用”的问题。主要原因是计算筛选是一个富集过程。有意义的化合物选择不一定需要精确计算出的能量和得分；好的选择策略可以弥补一些方法上的不足。</p>
<p>例如，在典型的对接研究中，大型化合物数据库中可以过滤掉一些，最终可能得到100个左右候选化合物。</p>
<p>为了缩小选择的范围，过滤掉不合适的化合物（大多数数据库化合物都是如此）与寻找最有希望的候选物一样重要。重要的是，考虑到计算因素，比特异性选择更容易实现的是过滤掉不适合的化合物。此外，只要在候选清单中找到活性化合物，它们的<strong>相对排名就不再重要</strong>。简而言之，只要对这些化合物进行测试，就可以在前五名得分最高的化合物中获得与前五十名得分相同的活性，这进一步弥补了得分的局限性。此外，对相当少量的候选对象（例如100-500）进行目视检查也是一种相当普遍的做法，这给选拔过程增加了另一个维度（即化学直觉，知识和经验）。</p>
<p>因此，尽管虚拟筛选不可避免地会产生假阳性和阴性，但将结果分析合理化为富集过程有助于解释其成功之处。</p>
<p>甚至非常快速的对接和计分方法，每个化合物通常也需要数秒至数十秒的时间才能完全灵活地进行搜索，因此，在存在数百万种数据库化合物的情况下，这种方法变得难以为继。结果，通常只有在通过应用过滤方法显着减小了源数据库的大小之后，才可以执行复杂的POSE和打分方案。</p>
<h4 id="靶点结构（Structures-of-target-sites）"><a href="#靶点结构（Structures-of-target-sites）" class="headerlink" title="靶点结构（Structures of target sites）"></a>靶点结构（<em>Structures of target sites</em>）</h4><p>结合位点的结构模型的选择和准备是重要的变量。通常优选由实验确定的（X射线或核磁共振）结构。然而，由于具有药学意义的蛋白质的数量增长快于结构已确定的数量，同源性建模也已逐渐普及。</p>
<p>最近的一项研究比较了使用HOLO-或APO-ENZYMES的晶体结构或同源模型作为模板时，对接结果的质量。令人惊讶的是，在10个测试案例中，同源模型有更高的富集因子，脱辅酶和同源性建模的结构表现相当好。但是，最佳性能仍然是结合配体的蛋白质构象。该研究表明，即使由配体结合引起的微小蛋白质构象变化也足以显著影响对接结果的质量。然而，在高序列相似性的情况下建立的同源性模型也提供了合理的对接模板。</p>
<h4 id="预筛选：三维过滤（Pre-screening-three-dimensional-filtering-）"><a href="#预筛选：三维过滤（Pre-screening-three-dimensional-filtering-）" class="headerlink" title="预筛选：三维过滤（Pre-screening: three-dimensional filtering.）"></a>预筛选：三维过滤（Pre-screening: three-dimensional filtering.）</h4><p>除了常规的一维/二维过滤器（例如类药五规则）之外，还实现了三维过滤器功能，以有效地预筛选非常大的数据库并减少对接和打分步骤中化合物的数量。</p>
<p>例如，形状相似性方法可以应用于过滤。启发式算法基于在特征，三重态，四重态或原子的更高阶组的基础上识别相似的分子形状。但是，这些形状过滤器通常仅限于预筛选包含<strong>单个分子构象</strong>的数据库，这也可能造成假阴性。</p>
<p>此外，在化合物中预先定义的化学和几何特征相匹配的情况下，可以进行基于药效团的筛选。最近，基于射线追踪的方法（ray-tracing-based approach）已被用于计算分子的形状特征以进行数据库搜索。这些类型的描述符也高度依赖构象，因此，当仅使用单个分子构象时，其预测值并不会很准确。</p>
<h3 id="基于结构的先导化合物优化（Structure-based-lead-optimization）"><a href="#基于结构的先导化合物优化（Structure-based-lead-optimization）" class="headerlink" title="基于结构的先导化合物优化（Structure-based lead optimization）"></a>基于结构的先导化合物优化（Structure-based lead optimization）</h3><p>除筛选之外，对接技术也越来越多地用于支持先导化合物优化的工作。在这里，通常必须将化合物的效价提高2到3个数量级，并且相对较小的化学修饰会导致结合力的显着变化。</p>
<p>估计相对较小的化学变化的影响的要求进一步使计算复杂化，因此，将微摩尔化合物与纳摩尔类似物区分开来通常需要比常规对接和计分所能提供的精度更高的精度。</p>
<p>但是，一旦将击中或先导与其靶共结晶并建立了精确的结合构象，就可以通过应用“锚定搜索” 等算法对类似物进行对接，该算法可按预定模式对化合物修饰进行建模保留核心片段。</p>
<p>这些“保守”预测的复合物通常仅包含有限数量的类似物，因此可以轻松探索替代和共识评分方案。在图2中示出了典型的基于结构的模拟设计。 至少，自动化的类似物设计和评估可以快速消除不满足结合约束的分子，并将重点转移到更有希望的合成候选物上。例如，从与水杨酸的共晶体结构开始优化了一系列caspase-3抑制剂。模拟类似物产生具有20nM效价的化合物，其化合物的结构已通过实验证实。超越了对类似物的一对一评估，将对接和模拟物库的设计相结合。对cathepsin D的研究已经很好地证明了这一点，该研究通过反复的锚定对接计算和针对性的文库设计产生了低nM抑制剂。 </p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210211130328408.png" alt="image-20210211130328408"></p>
<blockquote>
<p> 特定抑制剂的设计。 环氧合酶2（COX2）（PDB代码：1cx2）的活性位点与布洛芬，非选择性COX抑制剂（a）和选择性COX2抑制剂（b）形成复合物。 c显示了活性位点的surface。 d | 显示了其他几种有效的COX2抑制剂。 这些COX2先导化合物具有不同的分子骨架和官能团，可以使用对接技术（考虑结构信息）在活性部位的环境中进行计算模拟。</p>
</blockquote>
<h4 id="从头设计（De-novo-design-）"><a href="#从头设计（De-novo-design-）" class="headerlink" title="从头设计（De novo *design.*）"></a>从头设计（De novo *design.*）</h4><p>从头开始设计活性部位化合物的早期方法是多片段同时搜索（MCSS。许多小碎片在活动站点内停靠并同时最小化。在评分和分类之后，将优选的片段合并成更大的分子。与LUDI非常相似，MCSS的结果可以提供可能的亚位点的图谱，以结合所选的功能基团。在诸如Groupbuild，GenStar，Grow和Growmol之类的程序中实现了在结合位点内生长和评分化合物的其他算法。这种方法的已知局限性是难以通过计算来估计“设计者”分子的综合可及性。然而，SYNOPSIS程序代表了从头设计和综合设计相结合的最新努力。</p>
<p>例如，在一项针对HIV逆转录酶（HIV-RT）的研究中，从3.73亿个可能的候选分子中选择了一个仅包含28种化合物的小型文库。这是通过使用遗传算法同时评估适合度函数中嵌入的构象和合成参数来实现的。在28种选定的化合物中，可以合成18种，在这些分子中，有10种在100μM以下具有活性。在另一项研究中，使用蒙特卡罗组合生长算法和基于知识的评分方案构建了碳酸酐酶抑制剂。从约100,000个理论候选物中，仅选择了两种化合物进行合成，但均显示出亚nM效能。</p>
<h4 id="模拟（Simulations）"><a href="#模拟（Simulations）" class="headerlink" title="模拟（Simulations）"></a>模拟（<em>Simulations</em>）</h4><p>自由能模拟可用于评估有限数量的分子类似物；例如，一系列凝血酶抑制剂。为此，已经提出了各种近似方法来减少扰动计算的复杂性。例如，OwFeg方法对配体的结合态和非结合态进行自由能模拟计算，将能量变化映射到grid，这大大简化了将一个官能团转化为另一个官能团的计算。在模拟设计期间，可以监控与各种化学修饰能量相关的网格点。此外，利用配体相互作用能与蛋白质和溶剂环境的线性响应近似现在更普遍地应用于先导化合物优化中。这些方法至少需要几个可用的实验数据。应用定量构效关系（QSAR）来模拟系统中发生的非键相互作用。在对β-分泌酶，HIV-RT，Xa因子和雌激素受体的模拟设计研究中，线性响应方法已显示出一些有前景结果。<br>分子力学泊松-玻尔兹曼表面积（MM / PBSA）计算是另一种基于分子动力学的模拟技术，涉及力场和溶剂化这两个对结合很重要的项。使用连续泊松-玻尔兹曼模型估计溶剂化作用。 MM / PBSA和线性响应方法之间的主要区别在于未结合状态下配体的处理：MM / PBSA使用NORMAL MODE分析来计算焓和熵对配体自由能的贡献。该方法最近应用于神经氨酸酶和组织蛋白酶D53抑制剂的分析。</p>
<h4 id="活性位点分析（Active-site-analysis-）"><a href="#活性位点分析（Active-site-analysis-）" class="headerlink" title="活性位点分析（Active-site analysis. ）"></a>活性位点分析（<em>Active-site analysis.</em> ）</h4><p>自早期以来，结合位点的图形计算分析就极大地促进了基于结构的药物设计。</p>
<p>对接和模拟技术已应用于活性位点的分析中，包括各种疏水性和亲水性分子场，可以识别配体对接和/或从头设计的前景广阔的领域。表面图谱和分子场大多存储在网格中，用于半定量比较同源酶中的活性位点以探索特异性的差异。对活动场所中潜在相互作用的评估可以补充对接分析。</p>
<p>另一种最新方法是生成结构相互作用指纹（SIFts），允许在对接之前对数据库中的潜在配体进行预筛选。在探索锥虫硫醚还原酶的活性位点时，首先对接了44种不同的抑制剂，并对所得的结果进行了采样，并用于训练评分函数。然后将2,500种新化合物对接至活性位点，并使用该评分方案进行评估；选择了13种化合物进行测试，发现其中9种具有活性。</p>
<h4 id="吸收，分布，代谢及排泄（Absorption-distribution-metabolism-and-excretion-properties-）"><a href="#吸收，分布，代谢及排泄（Absorption-distribution-metabolism-and-excretion-properties-）" class="headerlink" title="吸收，分布，代谢及排泄（Absorption, distribution, metabolism and excretion properties. ）"></a>吸收，分布，代谢及排泄（<em>Absorption, distribution, metabolism and excretion properties.</em> ）</h4><p>目前，对接技术还用于辅助基于结构的吸收，分布，代谢和排泄（ADME）评估。 细胞色素P450亚型是主要的药物代谢酶，已成为代谢和药物相互作用研究的重点。 因此，几个研究小组已经开发出了基于结构的方法来预测可能被P450代谢或抑制的化合物，为此，已经产生了人类P450亚型的各种同源性模型作为对接以预测药物代谢的模板。 最近，确定了与warfarin结合的人P450亚型的晶体结构。 该抑制剂在酶中与铁-卟啉系统近端结合，但与辅因子没有直接相互作用。 这些结构见解应有助于进一步完善对人类P450的对接研究，并提高其预测价值。</p>
<blockquote>
<p>Well,目前来说基于ADMET的研究是一个热点，但是对接不是这个领域的主流。</p>
</blockquote>
<p><strong>一些虚拟筛选实验结果</strong></p>
<p><img src="https://gitee.com/luskyqi/markdown-png/raw/master/uPic/image-20210211125320953.png" alt="image-20210211125320953"></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>对接技术已在药物研究中应用了近二十年。基于蛋白质结构的虚拟筛选不同于基于分子相似性和配体的虚拟筛选方法，为活性化合物从头设计提供了机会，而不会偏向已知的先导化合物。对接策略和打分函数之间的相互关系相当复杂，但是生成可靠的配体模型比区分假阳性配体要容易得多。正如本文中所讨论的，打分和复合排名方案的进一步改进不一定取决于打分函数的发展。此外，复合过滤函数，基于二维或三维相似度的筛选模型经常与对接结合使用，以减少用于候选化合物的数量。尽管对接和打分依赖于许多近似值，但是这些技术在先导化合物优化过程中的应用（通常与其他计算方法结合使用）已经将更多传统方法扩展到SBDD。</p>
<h3 id="重要概念："><a href="#重要概念：" class="headerlink" title="重要概念："></a>重要概念：</h3><p>POSING（姿势）：确定配体的conformation和orientation是否适合活性位点的过程。 这通常是一个模糊过程，会返回许多结果</p>
<p>SCORING（打分）：posing和ranking都涉及得分。 pose分数通常是配体与活性位点结合的粗略度量。 rank分数通常更复杂，并且涉及到估算结合能。</p>
<p>RANKING（排序）：比posing score更高级的过程，通常会重新评估从初始计分阶段获取多个结果。 该过程通常试图尽可能准确地估计结合的自由能。 尽管posing阶段可能使用简单的能量计算（静电和范德华力），但ranking程序通常涉及更复杂的计算（也许包括诸如熵或显式溶剂化之类的属性）。</p>
<p>POSE SPACE（pose空间）：将一个分子放置到另外一个分子过程中所涉及的所有自由度。 例如，对于两个刚性分子，pose space仅由相对方向组成。 当两个分子之一（例如配体）具有柔性时，pose space既包括配体的构象空间又包括配体和受体的取向空间。</p>
<p>FORCE-FIELD（力场）：将系统能量表达为各种分子力学相关项（或其他项）总和的函数。</p>
<p>TORSIONAL ENTROPY（扭转熵）：与分子中可旋转键相关的熵。 将可旋转键固定在结合物上导致其扭转（或旋转）熵的损失。</p>
<p>REGRESSION ANALYSIS（回归分析）：确定所选（线性或非线性）函数的参数值以使其与观察值拟合。</p>
<p>POTENTIAL OF MEAN FORCE（PMF）：在对接和评分的背景下，PMF来自对大量蛋白质-配体结构中实验观察到的特定原子对相互作用的分布和频率的统计分析。 两个分子（例如配体和蛋白质）中每个原子对之间的相互作用电势近似于每个成对相互作用的自由能，它是原子间距离的函数。</p>
<p>LINEAR DISCRIMINANT ANALYSIS(线性判别分析)：基于两类数据和两个自变量（a，b）的数学分析，这些变量试图找到最能分隔数据的线。 这条线与判别函数正交，该判别函数是原始变量的线性组合，在这种情况下：F = caa + cbb（ca，cb;系数）。</p>
<p>PHARMACOPHORE（药效团）：已知或预测负责特定生物活性的分子中原子或基团的空间排列。</p>
<p>HOLO-, APO-ENZYME：Holo-：酶的配体结合形式；  apo-：非结合形式。 最初的定义是指酶和辅因子，而不是配体，但是配体和辅因子通常是同义词。</p>
<p>NORMAL MODE：系统所有粒子以相同的频率和相位运动的振荡。</p>
]]></content>
      <categories>
        <category>文献解读</category>
      </categories>
  </entry>
</search>
